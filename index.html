<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Analyse locale des appels 3CX</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0f172a;
      --card: #1e293b;
      --border: #334155;
      --text: #e2e8f0;
      --accent: #22c55e;
      --muted: #94a3b8;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
    }
    header {
      padding: 1.5rem 2rem;
      border-bottom: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.9);
      position: sticky;
      top: 0;
      backdrop-filter: blur(8px);
      z-index: 10;
    }
    h1 { margin: 0 0 0.3rem; font-size: 1.8rem; }
    p.subtitle { margin: 0; color: var(--muted); }
    main { padding: 1.5rem 2rem 3rem; display: grid; gap: 1rem; }
    section { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 1rem 1.25rem; }
    h2 { margin-top: 0; }
    .grid { display: grid; gap: 1rem; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); }
    .controls { display: flex; gap: 0.75rem; flex-wrap: wrap; }
    .chip {
      background: #0b1221;
      border: 1px solid var(--border);
      padding: 0.6rem 0.9rem;
      border-radius: 10px;
      flex: 1;
      min-width: 220px;
    }
    label { display: block; margin-bottom: 0.4rem; font-weight: 600; }
    input, select, button {
      width: 100%;
      padding: 0.65rem 0.75rem;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #0b1221;
      color: var(--text);
    }
    button.primary {
      background: var(--accent);
      color: #06240d;
      font-weight: 700;
      border: none;
      cursor: pointer;
      transition: transform 0.1s ease;
    }
    button.primary:active { transform: translateY(1px); }
    textarea {
      width: 100%;
      min-height: 110px;
      padding: 0.65rem 0.75rem;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #0b1221;
      color: var(--text);
      resize: vertical;
    }
    .dropzone {
      border: 1.5px dashed var(--border);
      border-radius: 12px;
      padding: 1rem;
      text-align: center;
      background: #0b1221;
      cursor: pointer;
    }
    .dropzone:hover { border-color: var(--accent); }
    .dropzone.dragging {
      border-color: var(--accent);
      background: rgba(34, 197, 94, 0.05);
    }
    .kpi-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 0.8rem; }
    .kpi { padding: 0.8rem; border-radius: 10px; border: 1px solid var(--border); background: #0b1221; }
    .kpi .label { color: var(--muted); font-size: 0.9rem; }
    .kpi .value { font-size: 1.4rem; font-weight: 700; margin-top: 0.2rem; }
    table { width: 100%; border-collapse: collapse; margin-top: 0.5rem; }
    th, td { padding: 0.55rem 0.65rem; text-align: left; border-bottom: 1px solid var(--border); }
    th { color: var(--muted); font-weight: 700; }
    tbody tr:hover { background: rgba(255, 255, 255, 0.03); }
    .muted { color: var(--muted); }
    .badge { padding: 0.2rem 0.45rem; border-radius: 6px; font-weight: 700; font-size: 0.85rem; }
    .badge.success { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
    .badge.warn { background: rgba(234, 179, 8, 0.15); color: #fbbf24; }
    .actions { display: flex; gap: 0.75rem; flex-wrap: wrap; }
    .chart-wrapper { position: relative; height: 260px; }
    @media (max-width: 680px) { header { position: static; } }
  </style>
</head>
<body>
  <header>
    <h1>Analyse locale des appels 3CX</h1>
    <p class="subtitle">Chargez vos CSV ou fichiers Excel, analysez hors-ligne, exportez et sauvegardez vos données directement dans le navigateur.</p>
  </header>

  <main>
    <section>
      <h2>1) Importer les CSV ou XLSX</h2>
      <div class="grid">
        <label class="dropzone">
            <input id="file-input" type="file" accept=".csv,.xls,.xlsx" multiple style="display:none" />
            Glissez-déposez vos fichiers CSV ou Excel ici ou cliquez pour les sélectionner (les données restent sur votre machine).
        </label>
        <div class="chip">
          <label for="paste-input">Coller des données CSV / Excel</label>
          <textarea id="paste-input" placeholder="Collez ici les lignes copiées depuis un tableur ou un fichier CSV (les données restent sur votre machine)."></textarea>
          <button id="paste-btn" class="primary" type="button" style="margin-top:0.5rem">Charger depuis le collage</button>
        </div>
        <div class="chip">
          <label>Sauvegarde navigateur (IndexedDB)</label>
          <div class="actions">
            <button id="save-local" class="primary" type="button">Sauvegarder les données</button>
            <button id="clear-local" type="button">Effacer la sauvegarde</button>
          </div>
          <p id="save-status" class="muted" style="margin-top:0.5rem">Aucune sauvegarde locale pour le moment.</p>
        </div>
      </div>
      <p id="file-summary" class="muted" style="margin-top:0.5rem">Aucun fichier chargé.</p>
    </section>

    <section>
      <h2>2) Filtres</h2>
      <div class="controls">
        <div class="chip">
          <label for="direction-select">Direction</label>
          <select id="direction-select" multiple size="4"></select>
        </div>
        <div class="chip">
          <label for="status-select">Statut</label>
          <select id="status-select" multiple size="4"></select>
        </div>
        <div class="chip">
          <label for="agent-select">Utilisateurs (agents / extensions)</label>
          <select id="agent-select" multiple size="6"></select>
        </div>
        <div class="chip">
          <label for="queue-select">Files d'attente</label>
          <select id="queue-select" multiple size="6"></select>
        </div>
        <div class="chip">
          <label>Période</label>
          <div class="controls" style="padding:0; gap:0.35rem; flex-wrap:nowrap;">
            <input id="start-date" type="date" />
            <input id="end-date" type="date" />
          </div>
        </div>
        <div class="chip">
          <label>Horaires (heures)</label>
          <div class="controls" style="padding:0; gap:0.35rem; flex-wrap:nowrap;">
            <input id="start-hour" type="number" min="0" max="23" step="1" />
            <input id="end-hour" type="number" min="0" max="23" step="1" />
          </div>
        </div>
        <div class="chip" style="align-self:flex-end">
          <button id="apply-filters" class="primary" type="button">Appliquer les filtres</button>
        </div>
      </div>
    </section>

    <section>
      <h2>Référentiels suivis</h2>
      <p class="muted">Liste fournie pour croiser rapidement les extensions utilisateurs et les files d'attente 3CX.</p>
      <div class="grid">
        <div>
          <h3>Extensions</h3>
          <div id="tracked-extensions"></div>
        </div>
        <div>
          <h3>Files d'attente</h3>
          <div id="tracked-queues"></div>
        </div>
      </div>
    </section>

    <section>
      <h2>3) Indicateurs clés</h2>
      <div class="kpi-grid" id="kpi-container"></div>
    </section>

    <section>
      <h2>4) Statistiques</h2>
      <div class="grid">
        <div>
          <h3>Par agent</h3>
          <div id="agent-stats"></div>
        </div>
        <div>
          <h3>Répartition temporelle</h3>
          <div class="chart-wrapper"><canvas id="date-chart"></canvas></div>
          <div class="chart-wrapper" style="margin-top:1rem"><canvas id="hour-chart"></canvas></div>
          <div class="chart-wrapper" style="margin-top:1rem"><canvas id="dow-chart"></canvas></div>
        </div>
      </div>
    </section>

    <section>
      <h2>5) Données</h2>
      <div class="actions" style="margin-bottom:0.5rem">
        <button id="export-btn" type="button">Exporter la sélection (CSV)</button>
      </div>
      <div id="data-table"></div>
    </section>
  </main>

  <script>
    const fileInput = document.getElementById('file-input');
    const fileSummary = document.getElementById('file-summary');
    const directionSelect = document.getElementById('direction-select');
    const statusSelect = document.getElementById('status-select');
    const agentSelect = document.getElementById('agent-select');
    const queueSelect = document.getElementById('queue-select');
    const startDateInput = document.getElementById('start-date');
    const endDateInput = document.getElementById('end-date');
    const startHourInput = document.getElementById('start-hour');
    const endHourInput = document.getElementById('end-hour');
    const kpiContainer = document.getElementById('kpi-container');
    const agentStats = document.getElementById('agent-stats');
    const dataTable = document.getElementById('data-table');
    const saveStatus = document.getElementById('save-status');
    const pasteInput = document.getElementById('paste-input');
    const trackedExtensionsContainer = document.getElementById('tracked-extensions');
    const trackedQueuesContainer = document.getElementById('tracked-queues');

    const TRACKED_EXTENSIONS = [
      { ext: '100', name: 'Abder Amazit' },
      { ext: '101', name: 'Ines Rodrigues' },
      { ext: '102', name: 'Imène Dikhissi' },
      { ext: '103', name: 'Bérangère Bai' },
      { ext: '104', name: 'Bassi Ouled Beidou' },
      { ext: '105', name: 'Christelle Vigee' },
      { ext: '106', name: 'Katia Raini' },
      { ext: '107', name: 'Compte en attente (1)' },
      { ext: '108', name: 'Mariam Chafai' },
      { ext: '109', name: 'Mariama Gassama' },
      { ext: '110', name: 'Mayana Augustin' },
      { ext: '111', name: 'Myreille Noel' },
      { ext: '112', name: 'Myriam Chenaf' },
      { ext: '113', name: 'Nathalie Beaussart' },
      { ext: '114', name: 'Sabrina Meskine' },
      { ext: '115', name: 'Sandrine Semedo Gonçalves' },
      { ext: '116', name: 'Salma Meskine' },
      { ext: '118', name: 'Mael Cosnet' },
      { ext: '123', name: 'Reynald Celini' },
      { ext: '124', name: 'Maud Autonomis' },
      { ext: '125', name: 'Hanane Abbadi' },
      { ext: '126', name: 'Aéline Njem belle Ekwe' },
      { ext: '127', name: 'Autonomis 1' },
      { ext: '128', name: 'Autonomis 2' },
    ];

    const TRACKED_QUEUES = [
      { number: '800', label: 'Annulation', group: 'Standard', associated: '0146037744 (SVI – ligne patient)' },
      { number: '801', label: 'Visite_Dom', group: 'Standard', associated: '0146037744 (SVI – ligne patient)' },
      { number: '802', label: 'Consult_Teleconsult', group: 'Standard', associated: '0146037744 (SVI – ligne patient)' },
      { number: '803', label: 'Demande_Admin', group: 'Standard', associated: '0146037744 (SVI – ligne patient)' },
      { number: '804', label: 'Medecin', group: 'Standard', associated: '146032345 (Medecin)' },
      { number: '805', label: 'Autonomis', group: 'Autonomis', associated: '973793043 (Ligne AUTONOMIS)' },
      { number: '806', label: 'Sobel', group: 'SOS92', associated: '146032369 (Sobel)' },
      { number: '807', label: 'Samu', group: '—', associated: '146032110 (Samu)' },
      { number: '808', label: 'RH', group: '—', associated: '146037678' },
      { number: '809', label: 'Prioritaire', group: 'N/C', associated: '—' },
      { number: '810', label: 'Assistance (Med evasan)', group: 'Standard', associated: '146038538' },
      { number: '811', label: 'FERMETURE CP (Répondeur numérique)', group: 'N/C', associated: '—' },
      { number: '812', label: 'Dr. Bolourian', group: 'Standard', associated: 'N/C' },
      { number: '880', label: 'demo', group: '—', associated: '146037577' },
    ];

    const trackedExtensionMap = new Map(TRACKED_EXTENSIONS.map((entry) => [entry.ext, entry.name]));
    const trackedQueueMap = new Map(TRACKED_QUEUES.map((entry) => [entry.number, entry]));

    function renderReferenceTables() {
      if (trackedExtensionsContainer) {
        const html = `
          <table>
            <thead><tr><th>Extension</th><th>Nom</th></tr></thead>
            <tbody>
              ${TRACKED_EXTENSIONS.map((entry) => `<tr><td>${entry.ext}</td><td>${entry.name}</td></tr>`).join('')}
            </tbody>
          </table>`;
        trackedExtensionsContainer.innerHTML = html;
      }

      if (trackedQueuesContainer) {
        const html = `
          <table>
            <thead><tr><th>Numéro</th><th>Libellé</th><th>Groupe</th><th>Numéro associé</th></tr></thead>
            <tbody>
              ${TRACKED_QUEUES.map(
                (entry) => `<tr><td>${entry.number}</td><td>${entry.label}</td><td>${entry.group}</td><td>${entry.associated}</td></tr>`,
              ).join('')}
            </tbody>
          </table>`;
        trackedQueuesContainer.innerHTML = html;
      }
    }

    let rawData = [];
    let filteredData = [];
    let charts = {};

    const DB_NAME = 'appels3cx-db';
    const DB_VERSION = 1;
    const DB_STORE = 'calls';

    fileInput.addEventListener('change', (event) => handleFiles(event.target.files));
    document.getElementById('apply-filters').addEventListener('click', applyFilters);
    document.getElementById('export-btn').addEventListener('click', exportFiltered);
    document.getElementById('save-local').addEventListener('click', manualPersist);
    document.getElementById('clear-local').addEventListener('click', clearIndexedDB);
    document.getElementById('paste-btn').addEventListener('click', handlePasteData);

    const dropzone = document.querySelector('.dropzone');
    dropzone.addEventListener('click', () => fileInput.click());
    dropzone.addEventListener('dragover', (event) => {
      event.preventDefault();
      dropzone.classList.add('dragging');
    });
    dropzone.addEventListener('dragleave', () => dropzone.classList.remove('dragging'));
    dropzone.addEventListener('drop', (event) => {
      event.preventDefault();
      dropzone.classList.remove('dragging');
      handleFiles(event.dataTransfer.files);
    });

    function openDatabase() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(DB_STORE)) {
            db.createObjectStore(DB_STORE, { keyPath: 'id', autoIncrement: true });
          }
        };

        request.onsuccess = (event) => resolve(event.target.result);
        request.onerror = (event) => reject(event.target.error);
      });
    }

    async function persistDataset(rows) {
      try {
        const db = await openDatabase();
        await new Promise((resolve, reject) => {
          const tx = db.transaction(DB_STORE, 'readwrite');
          const store = tx.objectStore(DB_STORE);
          store.clear();
          rows.forEach((row) => {
            const { id: _ignored, ...payload } = row;
            store.add(payload);
          });
          tx.oncomplete = resolve;
          tx.onerror = () => reject(tx.error);
        });
        saveStatus.textContent = 'Données sauvegardées dans IndexedDB (stockage disque du navigateur).';
      } catch (error) {
        console.error('Impossible de sauvegarder dans IndexedDB', error);
        saveStatus.textContent = "Échec de la sauvegarde IndexedDB. Les données restent en mémoire vive.";
      }
    }

    async function restoreFromIndexedDB() {
      try {
        const db = await openDatabase();
        const rows = await new Promise((resolve, reject) => {
          const result = [];
          const tx = db.transaction(DB_STORE, 'readonly');
          const store = tx.objectStore(DB_STORE);
          const cursorReq = store.openCursor();
          cursorReq.onsuccess = (event) => {
            const cursor = event.target.result;
            if (cursor) {
              const { id: _ignored, ...payload } = cursor.value;
              result.push(payload);
              cursor.continue();
            } else {
              resolve(result);
            }
          };
          cursorReq.onerror = () => reject(cursorReq.error);
        });

        if (rows.length) {
          rawData = rows;
          fileSummary.textContent = `Données restaurées depuis IndexedDB – ${rawData.length} lignes.`;
          populateFilters(rawData);
          applyFilters();
          saveStatus.textContent = 'Données chargées depuis IndexedDB.';
        }
      } catch (error) {
        console.error('Lecture IndexedDB impossible', error);
      }
    }

    async function clearIndexedDB() {
      await new Promise((resolve, reject) => {
        const req = indexedDB.deleteDatabase(DB_NAME);
        req.onsuccess = resolve;
        req.onerror = () => reject(req.error);
      });
      rawData = [];
      filteredData = [];
      dataTable.innerHTML = '';
      kpiContainer.innerHTML = '';
      agentStats.innerHTML = '';
      fileSummary.textContent = 'Sauvegarde supprimée.';
      saveStatus.textContent = 'Aucune sauvegarde locale pour le moment.';
    }

    async function manualPersist() {
      if (!rawData.length) return alert('Chargez des fichiers avant de sauvegarder.');
      await persistDataset(rawData);
    }

    function handleFiles(files) {
      if (!files || !files.length) return;
      const parsePromises = Array.from(files).map(parseFile);

      Promise.all(parsePromises)
        .then(async (dataArrays) => {
          const merged = dataArrays.flat();
          await ingestRows(merged, `${files.length} fichier(s) chargé(s)`);
        })
        .catch((err) => {
          console.error(err);
          fileSummary.textContent = "Erreur lors du chargement des fichiers.";
        });
    }

    async function ingestRows(rows, summaryLabel) {
      if (!rows || !rows.length) {
        fileSummary.textContent = `${summaryLabel} – aucune ligne détectée.`;
        return;
      }
      const merged = rawData.concat(rows);
      const { rows: cleaned, duplicates } = buildDataset(merged);
      rawData = cleaned;
      const duplicateNote = duplicates
        ? ` (${duplicates} doublon(s) ignoré(s) sur ${merged.length} lignes chargées)`
        : '';
      fileSummary.textContent = `${summaryLabel} – ${rawData.length} lignes après nettoyage${duplicateNote}.`;
      await persistDataset(rawData);
      populateFilters(rawData);
      applyFilters();
    }

    async function handlePasteData() {
      const text = pasteInput.value.trim();
      if (!text) return alert('Collez d\'abord des données copiées depuis votre fichier.');

      const parsed = Papa.parse(text, { header: true, skipEmptyLines: 'greedy', dynamicTyping: false });
      if (parsed.errors && parsed.errors.length) {
        console.warn('Erreurs lors du collage :', parsed.errors);
      }

      if (!parsed.data || !parsed.data.length) {
        return alert('Aucune ligne détectée dans les données collées.');
      }

      await ingestRows(parsed.data, 'Données collées');
      pasteInput.value = '';
    }

    function parseFile(file) {
      const ext = file.name.split('.').pop().toLowerCase();

      if (['xlsx', 'xls'].includes(ext)) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const workbook = XLSX.read(new Uint8Array(e.target.result), {
                type: 'array',
                cellDates: true,
              });
              const sheetName = workbook.SheetNames[0];
              if (!sheetName) return resolve([]);
              const sheet = workbook.Sheets[sheetName];
              const json = XLSX.utils.sheet_to_json(sheet, { defval: '', raw: false });
              resolve(json);
            } catch (error) {
              reject(error);
            }
          };
          reader.onerror = reject;
          reader.readAsArrayBuffer(file);
        });
      }

      return new Promise((resolve, reject) => {
        Papa.parse(file, {
          header: true,
          skipEmptyLines: true,
          complete: (results) => resolve(results.data),
          error: reject,
        });
      });
    }

    function normalizeKey(key) {
      return String(key || '')
        .replace(/^\ufeff+/, '')
        .trim()
        .normalize('NFKD')
        .replace(/[\u0300-\u036f]/g, '')
        .toLowerCase()
        .replace(/\s+/g, ' ');
    }

    function normalizeRecord(record) {
      const normalized = {};
      Object.entries(record || {}).forEach(([key, value]) => {
        const normalizedKey = normalizeKey(key);
        normalized[normalizedKey] = typeof value === 'string' ? value.trim() : value;
      });
      return normalized;
    }

    function readField(record, candidates, fallback = '') {
      for (const candidate of candidates) {
        const normalizedKey = normalizeKey(candidate);
        if (record.hasOwnProperty(normalizedKey)) return record[normalizedKey];
      }
      return fallback;
    }

    function convertDuration(value) {
      if (value === null || value === undefined || value === '') return 0;
      if (typeof value === 'number') return value;
      const text = String(value).trim();
      const match = text.match(/^(\d+):(\d{1,2})(?::(\d{1,2})(?:\.\d+)?)?$/);
      if (match) {
        const [, a, b, c] = match;
        const hours = c !== undefined ? Number(a) : 0;
        const minutes = c !== undefined ? Number(b) : Number(a);
        const seconds = c !== undefined ? Number(c) : Number(b);
        return hours * 3600 + minutes * 60 + seconds;
      }
      const numeric = Number(text.replace(',', '.'));
      return Number.isFinite(numeric) ? numeric : 0;
    }

    const trackedExtensionNumbers = TRACKED_EXTENSIONS.map((entry) => entry.ext);
    const trackedQueueNumbers = TRACKED_QUEUES.map((entry) => entry.number);

    function extractAgent(from, to) {
      const regex = /([^()]+?)\s*\((\d{2,})\)/;
      const candidates = [from, to];
      for (const candidate of candidates) {
        const match = regex.exec(candidate || '');
        if (match) {
          return { name: match[1].trim(), ext: match[2] };
        }
      }
      return { name: '', ext: '' };
    }

    function findTrackedExtension(...fields) {
      for (const field of fields) {
        const text = (field || '').toString();
        for (const ext of trackedExtensionNumbers) {
          const regex = new RegExp(`\\b${ext}\\b`);
          if (regex.test(text)) return ext;
        }
      }
      return '';
    }

    function findTrackedQueue(...fields) {
      for (const field of fields) {
        const text = (field || '').toString();
        for (const number of trackedQueueNumbers) {
          const regex = new RegExp(`\\b${number}\\b`);
          if (regex.test(text)) return trackedQueueMap.get(number);
        }
      }
      return null;
    }

    function categorizeCall(direction, to, details) {
      const dir = (direction || '').trim().toLowerCase();
      const toText = (to || '').toLowerCase();
      const detailText = (details || '').toLowerCase();
      if (toText.includes('voicemail') || detailText.includes('voicemail')) return 'Voicemail';
      if (toText.includes('script') || detailText.includes('call script')) return 'Script';
      if (['inbound', 'outbound', 'internal'].includes(dir)) return dir.charAt(0).toUpperCase() + dir.slice(1);
      return 'Autre';
    }

    function isoWeek(date) {
      const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
      const dayNum = d.getUTCDay() || 7;
      d.setUTCDate(d.getUTCDate() + 4 - dayNum);
      const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
      return Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
    }

    function parseDateTime(value) {
      if (!value) return null;
      if (value instanceof Date && !Number.isNaN(value)) return value;
      if (typeof value === 'number') {
        const excel = new Date(Math.round((value - 25569) * 86400 * 1000));
        if (!Number.isNaN(excel)) return excel;
      }
      const text = String(value).trim();
      const direct = Date.parse(text);
      if (!Number.isNaN(direct)) return new Date(direct);

      const ampmMatch = text.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})\s+(\d{1,2}):(\d{2})(?::(\d{2}))?\s*(AM|PM)$/i);
      if (ampmMatch) {
        const [, d, m, y, hh, mm, ss = '0', suffix] = ampmMatch;
        const year = y.length === 2 ? 2000 + Number(y) : Number(y);
        let hours = Number(hh) % 12;
        if (suffix.toUpperCase() === 'PM') hours += 12;
        return new Date(year, Number(m) - 1, Number(d), hours, Number(mm), Number(ss));
      }

      const match = text.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})(?:\s+(\d{1,2}):(\d{2})(?::(\d{2}))?)?$/);
      if (match) {
        const [, d, m, y, hh = '0', mm = '0', ss = '0'] = match;
        const year = y.length === 2 ? 2000 + Number(y) : Number(y);
        return new Date(year, Number(m) - 1, Number(d), Number(hh), Number(mm), Number(ss));
      }
      return null;
    }

    function buildDataset(rows) {
      const occurrences = new Map();
      const cleanedRows = [];
      let duplicateCounter = 0;

      rows.forEach((row) => {
        const normalized = normalizeRecord(row);
        const callTimeRaw = readField(normalized, ['Call Time', 'Call Start Time', 'Start Time', 'Date', 'Date/Heure', 'Debut']);
        const from = readField(normalized, ['From', 'De', 'Origine']);
        const to = readField(normalized, ['To', 'Vers', 'Destinataire']);
        const direction = readField(normalized, ['Direction', 'Sens']);
        const status = readField(normalized, ['Status', 'Statut']);
        const ringing = readField(normalized, ['Ringing', 'Sonnerie']);
        const talking = readField(normalized, ['Talking', 'Parole', 'Conversation']);
        const callId = readField(normalized, ['Call ID', 'ID', 'ID Appel']);
        const details = readField(normalized, ['Call Activity Details', 'Details']);

        const callTime = parseDateTime(callTimeRaw);
        const agent = extractAgent(from, to);
        const queueInfo = findTrackedQueue(from, to, details);
        const extension = agent.ext || findTrackedExtension(from, to);
        const agentName = agent.name || trackedExtensionMap.get(extension) || '';
        const record = {
          'Call ID': callId,
          'Call Time': callTimeRaw,
          From: from,
          To: to,
          Direction: direction,
          Status: status,
          'Call Activity Details': details,
          AgentName: agentName || agent.name,
          AgentLabel: agentName || agent.name || (extension ? `Ext ${extension}` : ''),
          AgentExt: extension,
          AgentTracked: Boolean(extension && trackedExtensionMap.has(extension)),
          QueueNumber: queueInfo?.number || '',
          QueueLabel: queueInfo?.label || '',
          QueueGroup: queueInfo?.group || '',
          QueueAssociated: queueInfo?.associated || '',
          QueueTracked: Boolean(queueInfo),
          RingingSeconds: convertDuration(ringing),
          TalkingSeconds: convertDuration(talking),
          DirectionClean: (direction || '').toString().trim(),
          StatusClean: (status || '').toString().trim(),
          CallTime: callTime,
          Date: callTime ? callTime.toISOString().slice(0, 10) : '',
          Year: callTime ? callTime.getFullYear() : '',
          Month: callTime ? callTime.getMonth() + 1 : '',
          Week: callTime ? isoWeek(callTime) : '',
          DayOfWeek: callTime ? callTime.toLocaleDateString('fr-FR', { weekday: 'long' }) : '',
          Hour: callTime ? callTime.getHours() : '',
        };
        record.CallType = categorizeCall(record.DirectionClean, record.To, record['Call Activity Details']);

        const callTimeKey = record.CallTime instanceof Date
          ? record.CallTime.toISOString()
          : (record.CallTime || '');
        const key = [
          record['Call ID'] || '',
          callTimeKey,
          record.From || '',
          record.To || '',
          record.DirectionClean || '',
          record.StatusClean || '',
          record['Call Activity Details'] || '',
          record.RingingSeconds ?? '',
          record.TalkingSeconds ?? '',
        ].join('|');
        const occurrence = occurrences.get(key) ?? 0;
        occurrences.set(key, occurrence + 1);

        if (occurrence > 0) {
          duplicateCounter += 1;
          return; // on ignore les doublons pour éviter le comptage multiple
        }

        cleanedRows.push(record);
      });
      return { rows: cleanedRows, duplicates: duplicateCounter };
    }

    function populateFilters(data) {
      const directions = Array.from(new Set(data.map((d) => d.DirectionClean).filter(Boolean))).sort();
      const statuses = Array.from(new Set(data.map((d) => d.StatusClean).filter(Boolean))).sort();
      directionSelect.innerHTML = directions.map((dir) => `<option value="${dir}">${dir}</option>`).join('');
      statusSelect.innerHTML = statuses.map((st) => `<option value="${st}">${st}</option>`).join('');

      const agentOptions = Array.from(
        new Map(
          data
            .filter((d) => d.AgentExt || d.AgentLabel)
            .map((d) => {
              const value = (d.AgentExt || d.AgentLabel || '').toString();
              const label = d.AgentLabel || (d.AgentExt ? `Ext ${d.AgentExt}` : value);
              return [value.toLowerCase(), { value, label }];
            }),
        ).values(),
      ).sort((a, b) => a.label.localeCompare(b.label, 'fr'));

      agentSelect.innerHTML = agentOptions
        .map((agent) => `<option value="${agent.value}">${agent.label}</option>`)
        .join('');

      const queueOptions = Array.from(
        new Map(
          data
            .filter((d) => d.QueueLabel || d.QueueNumber)
            .map((d) => {
              const value = (d.QueueNumber || d.QueueLabel || '').toString();
              const label = [d.QueueLabel, d.QueueNumber].filter(Boolean).join(' · ');
              return [value.toLowerCase(), { value, label: label || value }];
            }),
        ).values(),
      ).sort((a, b) => a.label.localeCompare(b.label, 'fr'));

      queueSelect.innerHTML = queueOptions
        .map((queue) => `<option value="${queue.value}">${queue.label}</option>`)
        .join('');

      const dates = data.map((d) => d.Date).filter(Boolean).sort();
      if (dates.length) {
        startDateInput.min = endDateInput.min = dates[0];
        startDateInput.max = endDateInput.max = dates[dates.length - 1];
        if (!startDateInput.value) startDateInput.value = dates[0];
        if (!endDateInput.value) endDateInput.value = dates[dates.length - 1];
      }

      if (!startHourInput.value) startHourInput.value = 0;
      if (!endHourInput.value) endHourInput.value = 23;

      saveStatus.textContent = 'Données chargées ; sauvegarde automatique dans IndexedDB.';
    }

    function applyFilters() {
      if (!rawData.length) return;
      const selectedDirections = Array.from(directionSelect.selectedOptions).map((o) => o.value.toLowerCase());
      const selectedStatuses = Array.from(statusSelect.selectedOptions).map((o) => o.value.toLowerCase());
      const selectedAgents = Array.from(agentSelect.selectedOptions).map((o) => o.value.toLowerCase());
      const selectedQueues = Array.from(queueSelect.selectedOptions).map((o) => o.value.toLowerCase());
      const startDate = startDateInput.value ? new Date(startDateInput.value) : null;
      const endDate = endDateInput.value ? new Date(endDateInput.value) : null;
      const startHour = startHourInput.value !== '' ? Number(startHourInput.value) : null;
      const endHour = endHourInput.value !== '' ? Number(endHourInput.value) : null;

      filteredData = rawData.filter((row) => {
        const dir = (row.DirectionClean || '').toLowerCase();
        const status = (row.StatusClean || '').toLowerCase();
        const agentValue = (row.AgentExt || row.AgentLabel || '').toString().toLowerCase();
        const queueValue = (row.QueueNumber || row.QueueLabel || '').toString().toLowerCase();
        const agentMatch = !selectedAgents.length || selectedAgents.includes(agentValue);
        const queueMatch = !selectedQueues.length || selectedQueues.includes(queueValue);

        const dateSource = row.CallTime ?? row.Date ?? null;
        const dateObj = dateSource ? new Date(dateSource) : null;
        const validDate = dateObj instanceof Date && !Number.isNaN(dateObj);
        const dateOk = !validDate || ((!startDate || dateObj >= startDate) && (!endDate || dateObj <= endDate));

        const hasHour = row.Hour !== '' && row.Hour !== null && row.Hour !== undefined;
        const hourOk = !hasHour ||
          (startHour === null && endHour === null) ||
          ((startHour === null || Number(row.Hour) >= startHour) && (endHour === null || Number(row.Hour) <= endHour));

        const dirOk = !selectedDirections.length || selectedDirections.includes(dir);
        const statusOk = !selectedStatuses.length || selectedStatuses.includes(status);
        return agentMatch && queueMatch && dateOk && hourOk && dirOk && statusOk;
      });

      renderKPIs();
      renderAgentTable();
      renderDataTable();
      renderCharts();
    }

    function renderKPIs() {
      const total = filteredData.length;
      const answered = filteredData.filter((r) => (r.StatusClean || '').toLowerCase() === 'answered').length;
      const missed = filteredData.filter((r) => ['no answer', 'missed'].includes((r.StatusClean || '').toLowerCase())).length;
      const totalTalk = filteredData.reduce((sum, r) => sum + (Number(r.TalkingSeconds) || 0), 0);
      const avgTalk = filteredData.length ? totalTalk / filteredData.length : 0;

      const kpis = [
        { label: 'Appels totaux', value: total },
        { label: 'Répondus', value: answered },
        { label: 'Manqués', value: missed },
        { label: 'Durée moyenne de conversation (s)', value: avgTalk.toFixed(1) },
      ];

      kpiContainer.innerHTML = kpis
        .map(
          (kpi) => `
            <div class="kpi">
              <div class="label">${kpi.label}</div>
              <div class="value">${kpi.value}</div>
            </div>`,
        )
        .join('');
    }

    function renderAgentTable() {
      const grouped = {};
      filteredData.forEach((row) => {
        const key = row.AgentLabel || row.AgentName || row.AgentExt || 'Inconnu';
        if (!grouped[key]) {
          grouped[key] = {
            Agent: key,
            Ext: row.AgentExt || '',
            Tracked: Boolean(row.AgentTracked),
            Appels: 0,
            Répondus: 0,
            Manqués: 0,
            TempsParole: 0,
          };
        }
        grouped[key].Appels += 1;
        const status = (row.StatusClean || '').toLowerCase();
        if (status === 'answered') grouped[key].Répondus += 1;
        if (['no answer', 'missed'].includes(status)) grouped[key].Manqués += 1;
        grouped[key].TempsParole += Number(row.TalkingSeconds) || 0;
      });

      const rows = Object.values(grouped).sort((a, b) => b.Appels - a.Appels);
      if (!rows.length) {
        agentStats.innerHTML = '<p class="muted">Aucune donnée à afficher.</p>';
        return;
      }
      const html = `
        <table>
          <thead>
            <tr>
              <th>Agent</th>
              <th>Appels</th>
              <th>Répondus</th>
              <th>Manqués</th>
              <th>Temps de parole moyen (s)</th>
            </tr>
          </thead>
          <tbody>
            ${rows
              .map(
                (r) => `
                  <tr>
                    <td>${r.Agent}${r.Ext ? ` (${r.Ext})` : ''}${r.Tracked ? ' ⭐' : ''}</td>
                    <td>${r.Appels}</td>
                    <td><span class="badge success">${r.Répondus}</span></td>
                    <td><span class="badge warn">${r.Manqués}</span></td>
                    <td>${(r.TempsParole / r.Appels || 0).toFixed(1)}</td>
                  </tr>`,
              )
              .join('')}
          </tbody>
        </table>`;
      agentStats.innerHTML = html;
    }

    function renderDataTable() {
      if (!filteredData.length) {
        dataTable.innerHTML = '<p class="muted">Aucune donnée à afficher.</p>';
        return;
      }
      const headers = [
        'Call Time',
        'From',
        'To',
        'Direction',
        'Status',
        'AgentLabel',
        'AgentExt',
        'AgentTracked',
        'QueueLabel',
        'QueueNumber',
        'QueueGroup',
        'QueueAssociated',
        'CallType',
        'TalkingSeconds',
        'RingingSeconds',
      ];
      const html = `
        <table>
          <thead>
            <tr>${headers.map((h) => `<th>${h}</th>`).join('')}</tr>
          </thead>
          <tbody>
            ${filteredData
              .slice(0, 400)
              .map(
                (row) => `
                  <tr>
                    ${headers
                      .map((h) => `<td>${row[h] ?? row[`${h}Clean`] ?? ''}</td>`)
                      .join('')}
                  </tr>`,
              )
              .join('')}
          </tbody>
        </table>
        <p class="muted">${filteredData.length > 400 ? 'Affichage limité aux 400 premières lignes pour garder de bonnes performances.' : ''}</p>`;
      dataTable.innerHTML = html;
    }

    function renderCharts() {
      const byDate = {};
      const byHour = Array(24).fill(0);
      const dowOrder = ['lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi', 'dimanche'];
      const byDow = Object.fromEntries(dowOrder.map((d) => [d, 0]));

      filteredData.forEach((row) => {
        if (row.Date) byDate[row.Date] = (byDate[row.Date] || 0) + 1;
        if (row.Hour !== '') byHour[Number(row.Hour)] += 1;
        const dow = (row.DayOfWeek || '').toLowerCase();
        if (dow in byDow) byDow[dow] += 1;
      });

      createChart('date-chart', 'line', {
        labels: Object.keys(byDate),
        datasets: [{ label: 'Appels', data: Object.values(byDate), borderColor: '#22c55e', tension: 0.2 }],
      });

      createChart('hour-chart', 'bar', {
        labels: Array.from({ length: 24 }, (_, i) => `${i}h`),
        datasets: [{ label: 'Appels', data: byHour, backgroundColor: '#22c55e' }],
      });

      createChart('dow-chart', 'bar', {
        labels: dowOrder.map((d) => d.charAt(0).toUpperCase() + d.slice(1)),
        datasets: [{ label: 'Appels', data: dowOrder.map((d) => byDow[d]), backgroundColor: '#22c55e' }],
      });
    }

    function createChart(id, type, data) {
      const ctx = document.getElementById(id);
      if (charts[id]) charts[id].destroy();
      charts[id] = new Chart(ctx, {
        type,
        data,
        options: { responsive: true, plugins: { legend: { display: false } } },
      });
    }

    function exportFiltered() {
      if (!filteredData.length) return alert('Aucune donnée filtrée à exporter.');
      const headers = Object.keys(filteredData[0]);
      const csv = [headers.join(',')].concat(
        filteredData.map((row) => headers.map((h) => JSON.stringify(row[h] ?? '')).join(',')),
      );
      const blob = new Blob([csv.join('\n')], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'appels_filtrés.csv';
      a.click();
      URL.revokeObjectURL(url);
    }

    renderReferenceTables();
    restoreFromIndexedDB();
  </script>
</body>
</html>
