<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Analyse des appels 3CX</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0f172a;
      --card: #1e293b;
      --border: #334155;
      --text: #e2e8f0;
      --accent: #22c55e;
      --muted: #94a3b8;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
    }
    header {
      padding: 1.5rem 2rem;
      border-bottom: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.9);
      position: sticky;
      top: 0;
      backdrop-filter: blur(8px);
      z-index: 10;
    }
    nav.tabs {
      display: flex;
      gap: 0.75rem;
      padding: 0 2rem 1rem;
      border-bottom: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.85);
      position: sticky;
      top: 78px;
      z-index: 9;
      backdrop-filter: blur(8px);
    }
    .tab-button {
      padding: 0.65rem 1.1rem;
      border-radius: 10px;
      background: #0b1221;
      border: 1px solid var(--border);
      color: var(--text);
      font-weight: 700;
      cursor: pointer;
      transition: all 0.15s ease;
    }
    .tab-button.active {
      background: var(--accent);
      color: #06240d;
      border-color: var(--accent);
    }
    .brand { display: flex; align-items: center; gap: 1rem; }
    h1 { margin: 0 0 0.3rem; font-size: 1.8rem; }
    p.subtitle { margin: 0; color: var(--muted); }
    main { padding: 1.5rem 2rem 3rem; display: grid; gap: 1rem; }
    section { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 1rem 1.25rem; }
    h2 { margin-top: 0; }
    .grid { display: grid; gap: 1rem; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); }
    .controls { display: flex; gap: 0.75rem; flex-wrap: wrap; }
    .filters-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 0.75rem;
    }
    .filters-grid + .filters-grid { margin-top: 0.75rem; }
    .chip {
      background: #0b1221;
      border: 1px solid var(--border);
      padding: 0.6rem 0.9rem;
      border-radius: 10px;
      flex: 1;
      min-width: 220px;
    }
    label { display: block; margin-bottom: 0.4rem; font-weight: 600; }
    input, select, button {
      width: 100%;
      padding: 0.65rem 0.75rem;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #0b1221;
      color: var(--text);
    }
    button.primary {
      background: var(--accent);
      color: #06240d;
      font-weight: 700;
      border: none;
      cursor: pointer;
      transition: transform 0.1s ease;
    }
    button.primary:active { transform: translateY(1px); }
    textarea {
      width: 100%;
      min-height: 110px;
      padding: 0.65rem 0.75rem;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #0b1221;
      color: var(--text);
      resize: vertical;
    }
    .dropzone {
      border: 1.5px dashed var(--border);
      border-radius: 12px;
      padding: 1rem;
      text-align: center;
      background: #0b1221;
      cursor: pointer;
    }
    .dropzone:hover { border-color: var(--accent); }
    .dropzone.dragging {
      border-color: var(--accent);
      background: rgba(34, 197, 94, 0.05);
    }
    .kpi-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(220px, 1fr));
      gap: 0.9rem;
    }
    .kpi { padding: 0.8rem; border-radius: 10px; border: 1px solid var(--border); background: #0b1221; }
    .kpi .label { color: var(--muted); font-size: 0.9rem; }
    .kpi .value { font-size: 1.4rem; font-weight: 700; margin-top: 0.2rem; }
    table { width: 100%; border-collapse: collapse; margin-top: 0.5rem; }
    th, td { padding: 0.55rem 0.65rem; text-align: left; border-bottom: 1px solid var(--border); }
    th { color: var(--muted); font-weight: 700; }
    tbody tr:hover { background: rgba(255, 255, 255, 0.03); }
    .muted { color: var(--muted); }
    .badge { padding: 0.2rem 0.45rem; border-radius: 6px; font-weight: 700; font-size: 0.85rem; }
    .badge.success { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
    .badge.warn { background: rgba(234, 179, 8, 0.15); color: #fbbf24; }
    .actions { display: flex; gap: 0.75rem; flex-wrap: wrap; }
    .chart-wrapper { position: relative; height: 260px; }
    .stats-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; }
    .stats-row + .stats-row {
      margin-top: 1.5rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border);
    }
    .stats-row.stats-charts { padding-top: 1.25rem; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    @media (max-width: 820px) { .brand { flex-direction: column; align-items: flex-start; } }
    @media (max-width: 780px) { .kpi-grid { grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); } }
    @media (max-width: 680px) { header { position: static; } }
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <div>
        <h1>Analyse des appels 3CX</h1>
        <p class="subtitle">Chargez vos fichiers CSV, analysez hors-ligne, exportez et sauvegardez vos données directement dans le navigateur.</p>
      </div>
    </div>
  </header>

  <nav class="tabs">
    <button class="tab-button active" data-tab-target="pilotage">Pilotage</button>
    <button class="tab-button" data-tab-target="import">Import</button>
  </nav>

  <main>
    <section class="tab-content" data-tab="import">
      <h2>Importer les CSV</h2>
      <div class="grid">
        <label class="dropzone">
            <input id="file-input" type="file" accept=".csv" multiple style="display:none" />
            Glissez-déposez vos fichiers CSV ici ou cliquez pour les sélectionner (les données restent sur votre machine).
        </label>
        <div class="chip">
          <label>Sauvegarde automatique</label>
          <div class="actions">
            <button id="clear-local" type="button">Effacer la sauvegarde locale</button>
          </div>
          <p id="save-status" class="muted" style="margin-top:0.5rem">Aucune sauvegarde locale pour le moment.</p>
        </div>
      </div>
      <p id="file-summary" class="muted" style="margin-top:0.5rem">Aucun fichier chargé.</p>
      <div id="imports-panel" style="margin-top:1rem" class="chip">
        <h3 style="margin-top:0;">Imports précédents</h3>
        <div id="import-list" class="muted">Aucun import enregistré.</div>
      </div>
    </section>

    <section class="tab-content" data-tab="pilotage">
      <h2>Filtres</h2>
      <div class="filters-grid">
        <div class="chip">
          <label for="direction-select">Direction</label>
          <select id="direction-select" multiple size="4"></select>
        </div>
        <div class="chip">
          <label for="status-select">Statut</label>
          <select id="status-select" multiple size="4"></select>
        </div>
        <div class="chip">
          <label for="agent-select">Utilisateurs</label>
          <select id="agent-select" multiple size="6"></select>
        </div>
        <div class="chip">
          <label for="queue-select">Files d'attente</label>
          <select id="queue-select" multiple size="6"></select>
        </div>
      </div>
      <div class="filters-grid">
        <div class="chip">
          <label>Période</label>
          <div class="controls" style="padding:0; gap:0.35rem; flex-wrap:nowrap;">
            <input id="start-date" type="date" />
            <input id="end-date" type="date" />
          </div>
        </div>
        <div class="chip">
          <label>Horaires (heures)</label>
          <div class="controls" style="padding:0; gap:0.35rem; flex-wrap:nowrap;">
            <input id="start-hour" type="number" min="0" max="23" step="1" />
            <input id="end-hour" type="number" min="0" max="23" step="1" />
          </div>
        </div>
        <div class="chip" style="align-self:flex-end">
          <button id="apply-filters" class="primary" type="button">Appliquer les filtres</button>
        </div>
      </div>
    </section>

    <section class="tab-content" data-tab="pilotage">
      <h2>Indicateurs clés</h2>
      <div class="kpi-grid" id="kpi-container"></div>
    </section>

    <section class="tab-content" data-tab="pilotage">
      <h2>Statistiques</h2>
      <div class="stats-row">
        <div>
          <h3>Standard</h3>
          <div id="standard-stats"></div>
        </div>
        <div>
          <h3>Files d'attente</h3>
          <div id="queue-stats"></div>
        </div>
      </div>
      <div class="stats-row stats-charts">
        <div>
          <h3>Répartition des appels par jour</h3>
          <div class="chart-wrapper"><canvas id="date-chart"></canvas></div>
        </div>
        <div>
          <h3>Répartition des appels par heure</h3>
          <div class="chart-wrapper"><canvas id="hour-chart"></canvas></div>
        </div>
      </div>
    </section>

    <section class="tab-content" data-tab="pilotage">
      <h2>Données</h2>
      <div class="actions" style="margin-bottom:0.5rem">
        <button id="export-btn" type="button">Exporter la sélection (CSV)</button>
      </div>
      <div id="data-table"></div>
    </section>
  </main>

  <script>
    const fileInput = document.getElementById('file-input');
    const fileSummary = document.getElementById('file-summary');
    const directionSelect = document.getElementById('direction-select');
    const statusSelect = document.getElementById('status-select');
    const agentSelect = document.getElementById('agent-select');
    const queueSelect = document.getElementById('queue-select');
    const startDateInput = document.getElementById('start-date');
    const endDateInput = document.getElementById('end-date');
    const startHourInput = document.getElementById('start-hour');
    const endHourInput = document.getElementById('end-hour');
    const tabButtons = document.querySelectorAll('.tab-button');
    const tabSections = document.querySelectorAll('.tab-content');
    const kpiContainer = document.getElementById('kpi-container');
    const standardStats = document.getElementById('standard-stats');
    const queueStats = document.getElementById('queue-stats');
    const dataTable = document.getElementById('data-table');
    const saveStatus = document.getElementById('save-status');
    const importList = document.getElementById('import-list');

    const TRACKED_EXTENSIONS = [
      { ext: '100', name: 'Abder Amazit' },
      { ext: '101', name: 'Ines Rodrigues' },
      { ext: '102', name: 'Imène Dikhissi' },
      { ext: '103', name: 'Bérangère Bai' },
      { ext: '104', name: 'Bassi Ouled Beidou' },
      { ext: '105', name: 'Christelle Vigee' },
      { ext: '106', name: 'Katia Raini' },
      { ext: '107', name: 'Compte en attente (1)' },
      { ext: '108', name: 'Mariam Chafai' },
      { ext: '109', name: 'Mariama Gassama' },
      { ext: '110', name: 'Mayana Augustin' },
      { ext: '111', name: 'Myreille Noel' },
      { ext: '112', name: 'Myriam Chenaf' },
      { ext: '113', name: 'Nathalie Beaussart' },
      { ext: '114', name: 'Sabrina Meskine' },
      { ext: '115', name: 'Sandrine Semedo Gonçalves' },
      { ext: '116', name: 'Salma Meskine' },
      { ext: '117', name: 'Extension 117' },
      { ext: '118', name: 'Mael Cosnet' },
      { ext: '119', name: 'Extension 119' },
      { ext: '120', name: 'Extension 120' },
      { ext: '121', name: 'Extension 121' },
      { ext: '122', name: 'Extension 122' },
      { ext: '123', name: 'Reynald Celini' },
      { ext: '124', name: 'Maud Autonomis' },
      { ext: '125', name: 'Hanane Abbadi' },
      { ext: '126', name: 'Aéline Njem belle Ekwe' },
      { ext: '127', name: 'Autonomis 1' },
      { ext: '128', name: 'Autonomis 2' },
      { ext: '129', name: 'Extension 129' },
      { ext: '130', name: 'Extension 130' },
    ];

    const TRACKED_QUEUES = [
      { number: '800', label: 'Annulation', group: 'Standard', associated: '0146037744 (SVI – ligne patient)' },
      { number: '801', label: 'Visite_Dom', group: 'Standard', associated: '0146037744 (SVI – ligne patient)' },
      { number: '802', label: 'Consult_Teleconsult', group: 'Standard', associated: '0146037744 (SVI – ligne patient)' },
      { number: '803', label: 'Demande_Admin', group: 'Standard', associated: '0146037744 (SVI – ligne patient)' },
      { number: '804', label: 'Medecin', group: 'Standard', associated: '146032345 (Medecin)' },
      { number: '805', label: 'Autonomis', group: 'Autonomis', associated: '973793043 (Ligne AUTONOMIS)' },
      { number: '806', label: 'Sobel', group: 'SOS92', associated: '146032369 (Sobel)' },
      { number: '807', label: 'Samu', group: '—', associated: '146032110 (Samu)' },
      { number: '808', label: 'RH', group: '—', associated: '146037678' },
      { number: '809', label: 'Prioritaire', group: 'N/C', associated: '—' },
      { number: '810', label: 'Assistance (Med evasan)', group: 'Standard', associated: '146038538' },
      { number: '811', label: 'FERMETURE CP (Répondeur numérique)', group: 'N/C', associated: '—' },
      { number: '812', label: 'Dr. Bolourian', group: 'Standard', associated: 'N/C' },
      { number: '880', label: 'demo', group: '—', associated: '146037577' },
    ];

    const trackedExtensionMap = new Map(TRACKED_EXTENSIONS.map((entry) => [entry.ext, entry.name]));
    const trackedQueueMap = new Map(TRACKED_QUEUES.map((entry) => [entry.number, entry]));

    const DIRECTION_LABELS = {
      inbound: 'Appel entrant',
      outbound: 'Appel sortant',
      'inbound queue': 'Passage en file',
      internal: 'Appel interne',
    };

    const STATUS_LABELS = {
      answered: 'Répondu',
      unanswered: 'Non répondu',
      busy: 'Occupé',
      failed: 'Échec',
    };

    let rawData = [];
    let filteredData = [];
    let eligibleData = [];
    let callAggregates = [];
    let extensionAggregates = { standard: [], medecin: [], queue: [], other: [] };
    let charts = {};
    let importLog = [];

    const DB_NAME = 'appels3cx-db';
    const DB_VERSION = 1;
    const DB_STORE = 'calls';

    fileInput.addEventListener('change', (event) => handleFiles(event.target.files));
    document.getElementById('apply-filters').addEventListener('click', applyFilters);
    document.getElementById('export-btn').addEventListener('click', exportFiltered);
    document.getElementById('clear-local').addEventListener('click', clearIndexedDB);
    tabButtons.forEach((btn) => btn.addEventListener('click', () => switchTab(btn.dataset.tabTarget)));

    const dropzone = document.querySelector('.dropzone');
    dropzone.addEventListener('click', () => fileInput.click());
    dropzone.addEventListener('dragover', (event) => {
      event.preventDefault();
      dropzone.classList.add('dragging');
    });
    dropzone.addEventListener('dragleave', () => dropzone.classList.remove('dragging'));
    dropzone.addEventListener('drop', (event) => {
      event.preventDefault();
      dropzone.classList.remove('dragging');
      handleFiles(event.dataTransfer.files);
    });

    function openDatabase() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(DB_STORE)) {
            db.createObjectStore(DB_STORE, { keyPath: 'id', autoIncrement: true });
          }
        };

        request.onsuccess = (event) => resolve(event.target.result);
        request.onerror = (event) => reject(event.target.error);
      });
    }

    async function persistDataset(rows) {
      try {
        const db = await openDatabase();
        await new Promise((resolve, reject) => {
          const tx = db.transaction(DB_STORE, 'readwrite');
          const store = tx.objectStore(DB_STORE);
          store.clear();
          rows.forEach((row) => {
            const { id: _ignored, ...payload } = row;
            store.add(payload);
          });
          tx.oncomplete = resolve;
          tx.onerror = () => reject(tx.error);
        });
        saveStatus.textContent = 'Données sauvegardées automatiquement dans le navigateur.';
      } catch (error) {
        console.error('Impossible de sauvegarder localement', error);
        saveStatus.textContent = "Échec de la sauvegarde locale. Les données restent en mémoire vive.";
      }
    }

    async function restoreFromIndexedDB() {
      try {
        const db = await openDatabase();
        const rows = await new Promise((resolve, reject) => {
          const result = [];
          const tx = db.transaction(DB_STORE, 'readonly');
          const store = tx.objectStore(DB_STORE);
          const cursorReq = store.openCursor();
          cursorReq.onsuccess = (event) => {
            const cursor = event.target.result;
            if (cursor) {
              const { id: _ignored, ...payload } = cursor.value;
              result.push(payload);
              cursor.continue();
            } else {
              resolve(result);
            }
          };
          cursorReq.onerror = () => reject(cursorReq.error);
        });

        if (rows.length) {
          rawData = rows;
          fileSummary.textContent = `Données restaurées depuis la sauvegarde locale – ${rawData.length} lignes.`;
          populateFilters(rawData);
          applyFilters();
          saveStatus.textContent = 'Données chargées depuis la sauvegarde locale.';
        }
      } catch (error) {
        console.error('Lecture de la sauvegarde locale impossible', error);
      }
    }

    async function clearIndexedDB() {
      await new Promise((resolve, reject) => {
        const req = indexedDB.deleteDatabase(DB_NAME);
        req.onsuccess = resolve;
        req.onerror = () => reject(req.error);
      });
      rawData = [];
      filteredData = [];
      callAggregates = [];
      extensionAggregates = { standard: [], medecin: [], queue: [], other: [] };
      dataTable.innerHTML = '';
      kpiContainer.innerHTML = '';
      standardStats.innerHTML = '';
      queueStats.innerHTML = '';
      fileSummary.textContent = 'Sauvegarde supprimée.';
      saveStatus.textContent = 'Aucune sauvegarde locale pour le moment.';
      importLog = [];
      localStorage.removeItem('import-log');
      renderImportList();
    }

    function handleFiles(files) {
      if (!files || !files.length) return;
      const imports = Array.from(files).map((file) =>
        parseFile(file)
          .then((rows) => ({ rows, fileName: file.name }))
          .catch((err) => {
            console.error(err);
            return { rows: [], fileName: file.name, error: true };
          }),
      );

      Promise.all(imports)
        .then(async (items) => {
          for (const item of items) {
            if (item.error) continue;
            await ingestRows(item.rows, item.fileName);
          }
        })
        .catch((err) => {
          console.error(err);
          fileSummary.textContent = "Erreur lors du chargement des fichiers.";
        });
    }

    async function ingestRows(rows, fileName) {
      if (!rows || !rows.length) {
        fileSummary.textContent = `${fileName} – aucune ligne détectée.`;
        return;
      }
      const importId = crypto.randomUUID ? crypto.randomUUID() : `imp_${Date.now()}_${Math.random().toString(16).slice(2)}`;
      const importedAt = new Date().toISOString();
      const taggedRows = rows.map((row) => ({ ...row, __importId: importId, __fileName: fileName, __importedAt: importedAt }));

      const merged = rawData.concat(taggedRows);
      const { rows: cleaned, duplicates } = buildDataset(merged);
      rawData = cleaned;
      const duplicateNote = duplicates
        ? ` (${duplicates} doublon(s) ignoré(s) sur ${merged.length} lignes chargées)`
        : '';
      fileSummary.textContent = `${fileName} – ${rawData.length} lignes après nettoyage${duplicateNote}.`;
      const importRows = rawData.filter((row) => row.ImportId === importId);
      addImportEntry(importId, fileName, importedAt, importRows);
      await persistDataset(rawData);
      populateFilters(rawData);
      applyFilters();
    }

    function parseFile(file) {
      return new Promise((resolve, reject) => {
        Papa.parse(file, {
          header: true,
          skipEmptyLines: true,
          complete: (results) => resolve(results.data),
          error: reject,
        });
      });
    }

    function normalizeKey(key) {
      return String(key || '')
        .replace(/^\ufeff+/, '')
        .trim()
        .normalize('NFKD')
        .replace(/[\u0300-\u036f]/g, '')
        .toLowerCase()
        .replace(/\s+/g, ' ');
    }

    function normalizeRecord(record) {
      const normalized = {};
      Object.entries(record || {}).forEach(([key, value]) => {
        const normalizedKey = normalizeKey(key);
        normalized[normalizedKey] = typeof value === 'string' ? value.trim() : value;
      });
      return normalized;
    }

    function readField(record, candidates, fallback = '') {
      for (const candidate of candidates) {
        const normalizedKey = normalizeKey(candidate);
        if (record.hasOwnProperty(normalizedKey)) return record[normalizedKey];
      }
      return fallback;
    }

    function convertDuration(value) {
      if (value === null || value === undefined || value === '') return 0;
      if (typeof value === 'number') return value;
      const text = String(value).trim();
      const match = text.match(/^(\d+):(\d{1,2})(?::(\d{1,2})(?:\.\d+)?)?$/);
      if (match) {
        const [, a, b, c] = match;
        const hours = c !== undefined ? Number(a) : 0;
        const minutes = c !== undefined ? Number(b) : Number(a);
        const seconds = c !== undefined ? Number(c) : Number(b);
        return hours * 3600 + minutes * 60 + seconds;
      }
      const numeric = Number(text.replace(',', '.'));
      return Number.isFinite(numeric) ? numeric : 0;
    }

    const trackedExtensionNumbers = TRACKED_EXTENSIONS.map((entry) => entry.ext);
    const trackedQueueNumbers = TRACKED_QUEUES.map((entry) => entry.number);

    function extractAgent(direction, from, to) {
      const regex = /([^()]+?)\s*\((\d{2,})\)/;
      const dir = (direction || '').toLowerCase();
      const candidates = dir.includes('outbound')
        ? [{ value: from, source: 'from' }]
        : dir.includes('inbound')
          ? [{ value: to, source: 'to' }]
          : [
              { value: from, source: 'from' },
              { value: to, source: 'to' },
            ];

      for (const candidate of candidates) {
        const match = regex.exec(candidate.value || '');
        if (match) {
          return { name: match[1].trim(), ext: match[2], source: candidate.source };
        }
      }
      return { name: '', ext: '', source: '' };
    }

    function findTrackedExtension(...fields) {
      for (const field of fields) {
        const text = (field || '').toString();
        for (const ext of trackedExtensionNumbers) {
          const regex = new RegExp(`\\b${ext}\\b`);
          if (regex.test(text)) return ext;
        }
      }
      return '';
    }

    function findTrackedQueue(...fields) {
      for (const field of fields) {
        const text = (field || '').toString();
        for (const number of trackedQueueNumbers) {
          const regex = new RegExp(`\\b${number}\\b`);
          if (regex.test(text)) {
            if (number === '992') return null;
            return trackedQueueMap.get(number);
          }
        }
      }
      return null;
    }

    function classifyExtension(ext) {
      const value = Number(ext);
      if (Number.isFinite(value) && value >= 100 && value <= 130) return 'standard';
      if (Number.isFinite(value) && value >= 132 && value <= 345) return 'medecin';
      if (Number.isFinite(value) && value >= 800) return 'queue';
      return 'other';
    }

    function categorizeCall(direction, to, details) {
      const dir = (direction || '').trim().toLowerCase();
      const toText = (to || '').toLowerCase();
      const detailText = (details || '').toLowerCase();
      if (toText.includes('voicemail') || detailText.includes('voicemail')) return 'Voicemail';
      if (toText.includes('script') || detailText.includes('call script')) return 'Script';
      if (['inbound', 'outbound', 'internal'].includes(dir)) return dir.charAt(0).toUpperCase() + dir.slice(1);
      return 'Autre';
    }

    function isoWeek(date) {
      const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
      const dayNum = d.getUTCDay() || 7;
      d.setUTCDate(d.getUTCDate() + 4 - dayNum);
      const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
      return Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
    }

    function parseDateTime(value) {
      if (!value) return null;
      if (value instanceof Date && !Number.isNaN(value)) return value;
      if (typeof value === 'number') {
        const excel = new Date(Math.round((value - 25569) * 86400 * 1000));
        if (!Number.isNaN(excel)) return excel;
      }
      const text = String(value).trim();
      const direct = Date.parse(text);
      if (!Number.isNaN(direct)) return new Date(direct);

      const ampmMatch = text.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})\s+(\d{1,2}):(\d{2})(?::(\d{2}))?\s*(AM|PM)$/i);
      if (ampmMatch) {
        const [, d, m, y, hh, mm, ss = '0', suffix] = ampmMatch;
        const year = y.length === 2 ? 2000 + Number(y) : Number(y);
        let hours = Number(hh) % 12;
        if (suffix.toUpperCase() === 'PM') hours += 12;
        return new Date(year, Number(m) - 1, Number(d), hours, Number(mm), Number(ss));
      }

      const match = text.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})(?:\s+(\d{1,2}):(\d{2})(?::(\d{2}))?)?$/);
      if (match) {
        const [, d, m, y, hh = '0', mm = '0', ss = '0'] = match;
        const year = y.length === 2 ? 2000 + Number(y) : Number(y);
        return new Date(year, Number(m) - 1, Number(d), Number(hh), Number(mm), Number(ss));
      }
      return null;
    }

    function buildDataset(rows) {
      const occurrences = new Map();
      const cleanedRows = [];
      let duplicateCounter = 0;

      rows.forEach((row) => {
        const normalized = normalizeRecord(row);
        const callTimeRaw = readField(normalized, ['Call Time', 'Call Start Time', 'Start Time', 'Date', 'Date/Heure', 'Debut']);
        const from = readField(normalized, ['From', 'De', 'Origine']);
        const to = readField(normalized, ['To', 'Vers', 'Destinataire']);
        const direction = readField(normalized, ['Direction', 'Sens']);
        const status = readField(normalized, ['Status', 'Statut']);
        const ringing = readField(normalized, ['Ringing', 'Sonnerie']);
        const talking = readField(normalized, ['Talking', 'Parole', 'Conversation']);
        const callId = readField(normalized, ['Call ID', 'ID', 'ID Appel']);
        const details = readField(normalized, ['Call Activity Details', 'Details']);

        const callTime = parseDateTime(callTimeRaw);
        const agent = extractAgent(direction, from, to);
        const queueInfo = findTrackedQueue(from, to, details);
        const extension = agent.ext;
        const agentName = agent.name || trackedExtensionMap.get(extension) || '';
        const extensionCategory = classifyExtension(extension);
        const isInbound = (direction || '').toLowerCase().includes('inbound');
        const isOutbound = (direction || '').toLowerCase().includes('outbound');
        const directionAligned =
          (isOutbound && agent.source === 'from') ||
          (isInbound && agent.source === 'to') ||
          (!isInbound && !isOutbound && !!extension);
        const record = {
          'Call ID': callId,
          'Call Time': callTimeRaw,
          From: from,
          To: to,
          Direction: direction,
          Status: status,
          'Call Activity Details': details,
          AgentName: agentName || agent.name,
          AgentLabel: extension
            ? `${extension} – ${agentName || agent.name || 'Extension inconnue'}`
            : agentName || agent.name,
          AgentExt: extension,
          AgentTracked: Boolean(extension && trackedExtensionMap.has(extension)),
          ExtensionCategory: extensionCategory,
          AgentDirectionMatch: directionAligned,
          QueueNumber: queueInfo?.number || '',
          QueueLabel: queueInfo?.label || '',
          QueueGroup: queueInfo?.group || queueInfo?.label || '',
          QueueAssociated: queueInfo?.associated || '',
          QueueTracked: Boolean(queueInfo),
          RingingSeconds: convertDuration(ringing),
          TalkingSeconds: convertDuration(talking),
          DirectionClean: (direction || '').toString().trim(),
          StatusClean: (status || '').toString().trim(),
          CallTime: callTime,
          Date: callTime ? callTime.toISOString().slice(0, 10) : '',
          Year: callTime ? callTime.getFullYear() : '',
          Month: callTime ? callTime.getMonth() + 1 : '',
          Week: callTime ? isoWeek(callTime) : '',
          DayOfWeek: callTime ? callTime.toLocaleDateString('fr-FR', { weekday: 'long' }) : '',
          Hour: callTime ? callTime.getHours() : '',
          ImportId: row.__importId || '',
          ImportFileName: row.__fileName || '',
          ImportedAt: row.__importedAt || '',
        };
        record.CallType = categorizeCall(record.DirectionClean, record.To, record['Call Activity Details']);

        const callTimeKey = record.CallTime instanceof Date
          ? record.CallTime.toISOString()
          : (record.CallTime || '');
        const key = [
          record['Call ID'] || '',
          callTimeKey,
          record.From || '',
          record.To || '',
          record.DirectionClean || '',
          record.StatusClean || '',
          record['Call Activity Details'] || '',
          record.RingingSeconds ?? '',
          record.TalkingSeconds ?? '',
        ].join('|');
        const occurrence = occurrences.get(key) ?? 0;
        occurrences.set(key, occurrence + 1);

        if (occurrence > 0) {
          duplicateCounter += 1;
          return; // on ignore les doublons pour éviter le comptage multiple
        }

        cleanedRows.push(record);
      });
      return { rows: cleanedRows, duplicates: duplicateCounter };
    }

    function directionLabel(value) {
      const key = (value || '').toString().toLowerCase();
      return DIRECTION_LABELS[key] || value;
    }

    function statusLabel(value) {
      const key = (value || '').toString().toLowerCase();
      return STATUS_LABELS[key] || value;
    }

    function populateFilters(data) {
      const directions = Array.from(new Set(
        data.map((d) => (d.DirectionClean || '').toLowerCase()).filter(Boolean),
      ))
        .filter((dir) => dir !== 'inbound queue')
        .sort();
      const statuses = Array.from(new Set(
        data.map((d) => (d.StatusClean || '').toLowerCase()).filter(Boolean),
      )).sort();
      directionSelect.innerHTML = ['<option value="__all__" selected>Toutes les directions</option>']
        .concat(directions.map((dir) => `<option value="${dir}">${directionLabel(dir)}</option>`))
        .join('');
      statusSelect.innerHTML = ['<option value="__all__" selected>Tous les statuts</option>']
        .concat(statuses.map((st) => `<option value="${st}">${statusLabel(st)}</option>`))
        .join('');

      const standardExtensions = Array.from({ length: 31 }, (_, i) => (100 + i).toString());
      const agentOptions = standardExtensions
        .map((ext) => ({ value: ext, label: `${ext} – ${trackedExtensionMap.get(ext) || 'Extension standard'}` }))
        .sort((a, b) => a.value.localeCompare(b.value, 'fr'));

      agentSelect.innerHTML = ['<option value="__all__" selected>Tous les utilisateurs</option>']
        .concat(agentOptions.map((agent) => `<option value="${agent.value}">${agent.label}</option>`))
        .join('');

      const queueOptionsMap = new Map();
      TRACKED_QUEUES.forEach((entry) => {
        const value = entry.number;
        const label = `${entry.number} – ${entry.label}`;
        if (value !== '992') queueOptionsMap.set(value.toLowerCase(), { value, label });
      });

      data
        .filter((d) => (d.QueueLabel || d.QueueNumber) && d.QueueNumber !== '992')
        .forEach((d) => {
          const value = (d.QueueNumber || d.QueueLabel || '').toString();
          const label = [d.QueueNumber, d.QueueLabel].filter(Boolean).join(' – ');
          queueOptionsMap.set(value.toLowerCase(), { value, label: label || value });
        });

      const queueOptions = Array.from(queueOptionsMap.values()).sort((a, b) =>
        a.label.localeCompare(b.label, 'fr'),
      );

      queueSelect.innerHTML = ['<option value="__all__" selected>Toutes les files</option>']
        .concat(queueOptions.map((queue) => `<option value="${queue.value}">${queue.label}</option>`))
        .join('');

      const dates = data.map((d) => d.Date).filter(Boolean).sort();
      if (dates.length) {
        startDateInput.min = endDateInput.min = dates[0];
        startDateInput.max = endDateInput.max = dates[dates.length - 1];
        if (!startDateInput.value) startDateInput.value = dates[0];
        if (!endDateInput.value) endDateInput.value = dates[dates.length - 1];
      }

      if (!startHourInput.value) startHourInput.value = 0;
      if (!endHourInput.value) endHourInput.value = 23;

      saveStatus.textContent = '';
    }

    function applyFilters() {
      if (!rawData.length) return;
      const selectedDirections = extractSelection(directionSelect);
      const selectedStatuses = extractSelection(statusSelect);
      const selectedAgents = extractSelection(agentSelect);
      const selectedQueues = extractSelection(queueSelect);
      const startDate = startDateInput.value ? new Date(startDateInput.value) : null;
      const endDate = endDateInput.value ? new Date(endDateInput.value) : null;
      const startHour = startHourInput.value !== '' ? Number(startHourInput.value) : null;
      const endHour = endHourInput.value !== '' ? Number(endHourInput.value) : null;

      filteredData = rawData.filter((row) => {
        const dir = (row.DirectionClean || '').toLowerCase();
        const status = (row.StatusClean || '').toLowerCase();
        const agentValue = (row.AgentExt || row.AgentLabel || '').toString().toLowerCase();
        const queueValue = (row.QueueNumber || row.QueueLabel || '').toString().toLowerCase();
        const agentMatch = !selectedAgents.length || selectedAgents.includes(agentValue);
        const queueMatch = !selectedQueues.length || selectedQueues.includes(queueValue);

        const dateSource = row.CallTime ?? row.Date ?? null;
        const dateObj = dateSource ? new Date(dateSource) : null;
        const validDate = dateObj instanceof Date && !Number.isNaN(dateObj);
        const dateOk = !validDate || ((!startDate || dateObj >= startDate) && (!endDate || dateObj <= endDate));

        const hasHour = row.Hour !== '' && row.Hour !== null && row.Hour !== undefined;
        const hourOk = !hasHour ||
          (startHour === null && endHour === null) ||
          ((startHour === null || Number(row.Hour) >= startHour) && (endHour === null || Number(row.Hour) <= endHour));

        const dirOk = !selectedDirections.length || selectedDirections.includes(dir);
        const statusOk = !selectedStatuses.length || selectedStatuses.includes(status);
        return agentMatch && queueMatch && dateOk && hourOk && dirOk && statusOk;
      });

      filteredData = filteredData.filter((row) => {
        const queueNumber = (row.QueueNumber || '').toString();
        const agentExtension = (row.AgentExt || '').toString();
        return queueNumber !== '992' && agentExtension !== '992';
      });

      eligibleData = filteredData.filter((row) => row.AgentDirectionMatch);

      callAggregates = aggregateCalls(eligibleData);
      extensionAggregates = aggregateExtensions(eligibleData);

      renderKPIs();
      renderCategoryTable(standardStats, extensionAggregates.standard || [], {
        answeredLabel: 'Appels réussis',
        showDirectionBreakdown: true,
      });
      const queueRows = (extensionAggregates.queue || []).map((row) => ({
        ...row,
        answered: Math.max(0, (row.calls || 0) - (row.failures || 0)),
      }));

      renderCategoryTable(queueStats, queueRows, {
        failureLabel: 'Appels perdus',
      });
      renderDataTable();
      renderCharts();
    }

    function extractSelection(selectEl) {
      const values = Array.from(selectEl.selectedOptions).map((o) => o.value.toLowerCase());
      return values.includes('__all__') ? [] : values;
    }

    function aggregateCalls(rows) {
      const byCall = new Map();

      rows.forEach((row, index) => {
        const callId = row['Call ID'] || `__missing_${index}`;
        const status = (row.StatusClean || '').toLowerCase();
        const isAnswered = status === 'answered';
        const isFailure = ['no answer', 'missed', 'unanswered', 'busy', 'failed'].includes(status);
        const callTime = row.CallTime instanceof Date ? row.CallTime : row.CallTime ? new Date(row.CallTime) : null;

        const current = byCall.get(callId) || {
          callId,
          answered: false,
          failures: false,
          talking: 0,
          ringing: 0,
          callTime: null,
          date: '',
          hour: '',
          dow: '',
        };

        current.answered = current.answered || isAnswered;
        current.failures = current.failures || (!current.answered && isFailure);
        current.talking += Number(row.TalkingSeconds) || 0;
        current.ringing += Number(row.RingingSeconds) || 0;

        if (callTime && (!current.callTime || callTime < current.callTime)) {
          current.callTime = callTime;
          current.date = row.Date || callTime.toISOString().slice(0, 10);
          current.hour = callTime.getHours();
          current.dow = callTime.toLocaleDateString('fr-FR', { weekday: 'long' });
        }

        byCall.set(callId, current);
      });

      return Array.from(byCall.values());
    }

    function aggregateExtensions(rows) {
      const perCallCategory = {
        standard: new Map(),
        medecin: new Map(),
        queue: new Map(),
        other: new Map(),
      };

      rows.forEach((row, index) => {
        const callId = row['Call ID'] || `__missing_${index}`;
        const status = (row.StatusClean || '').toLowerCase();
        const isAnswered = status === 'answered';
        const isFailure = ['no answer', 'missed', 'unanswered', 'busy', 'failed'].includes(status);
        const direction = (row.DirectionClean || '').toLowerCase();
        const isInbound = direction.includes('inbound');
        const isOutbound = direction.includes('outbound');

        const ext = row.AgentExt || '';
        const category = perCallCategory[row.ExtensionCategory] ? row.ExtensionCategory : 'other';
        const baseLabel =
          category === 'queue'
            ? row.QueueLabel || row.QueueNumber || row.AgentLabel || row.AgentName || ext || 'File inconnue'
            : row.AgentLabel || row.AgentName || ext || 'Autre / Inconnu';
        const keyLabel = baseLabel || 'Autre / Inconnu';
        const bucket = perCallCategory[category] || perCallCategory.other;
        const entryKey = `${callId}|${ext || keyLabel}`;

        const current = bucket.get(entryKey) || {
          label: keyLabel,
          ext: ext || keyLabel,
          calls: 0,
          answered: 0,
          failures: 0,
          inbound: 0,
          outbound: 0,
          talking: 0,
        };

        current.calls = 1;
        current.answered = current.answered || isAnswered ? 1 : 0;
        current.failures = current.answered ? 0 : current.failures || isFailure ? 1 : 0;
        current.inbound = isInbound ? 1 : 0;
        current.outbound = isOutbound ? 1 : 0;
        current.talking += Number(row.TalkingSeconds) || 0;
        bucket.set(entryKey, current);
      });

      const aggregateBucket = (map) => {
        const grouped = new Map();
        map.forEach((entry) => {
          const key = entry.ext || entry.label;
          const current = grouped.get(key) || {
            label: entry.label,
            ext: entry.ext,
            calls: 0,
            answered: 0,
            failures: 0,
            inbound: 0,
            outbound: 0,
            talking: 0,
          };
          current.calls += entry.calls;
          current.answered += entry.answered;
          current.failures += entry.failures;
          current.inbound += entry.inbound;
          current.outbound += entry.outbound;
          current.talking += entry.talking;
          grouped.set(key, current);
        });
        return Array.from(grouped.values()).sort((a, b) => b.calls - a.calls);
      };

      return {
        standard: aggregateBucket(perCallCategory.standard),
        medecin: aggregateBucket(perCallCategory.medecin),
        queue: aggregateBucket(perCallCategory.queue),
        other: aggregateBucket(perCallCategory.other),
      };
    }

    function renderKPIs() {
      const total = callAggregates.length;
      const answered = callAggregates.filter((c) => c.answered).length;
      const queueAbandoned = (extensionAggregates.queue || []).reduce(
        (sum, entry) => sum + (entry.failures || 0),
        0,
      );
      const totalTalk = callAggregates.reduce((sum, c) => sum + (Number(c.talking) || 0), 0);
      const avgTalk = total ? totalTalk / total : 0;

      const kpis = [
        { label: 'Appels totaux', value: total },
        { label: 'Répondus', value: answered },
        { label: 'Appels abandonnés', value: queueAbandoned },
        { label: 'Durée moyenne de conversation (s)', value: avgTalk.toFixed(1) },
      ];

      kpiContainer.innerHTML = kpis
        .map(
          (kpi) => `
            <div class="kpi">
              <div class="label">${kpi.label}</div>
              <div class="value">${kpi.value}</div>
            </div>`,
        )
        .join('');
    }

    function renderCategoryTable(
      container,
      rows,
      { answeredLabel = 'Répondus', failureLabel = "Échecs d'appel", showDirectionBreakdown = false } = {},
    ) {
      if (!rows.length) {
        container.innerHTML = '<p class="muted">Aucune donnée à afficher.</p>';
        return;
      }

      const directionHeaders = showDirectionBreakdown
        ? '<th>Appels entrants</th><th>Appels sortants</th>'
        : '';

      const html = `
        <table>
          <thead>
            <tr>
              <th>Extension</th>
              <th>Appels</th>
              ${directionHeaders}
              <th>${answeredLabel}</th>
              <th>${failureLabel}</th>
              <th>Temps de parole moyen (s)</th>
            </tr>
          </thead>
          <tbody>
            ${rows
              .map(
                (r) => `
                  <tr>
                    <td>${r.label}${r.ext ? ` (${r.ext})` : ''}</td>
                    <td>${r.calls}</td>
                    ${showDirectionBreakdown ? `<td>${r.inbound || 0}</td><td>${r.outbound || 0}</td>` : ''}
                    <td><span class="badge success">${r.answered}</span></td>
                    <td><span class="badge warn">${r.failures}</span></td>
                    <td>${(r.talking / r.calls || 0).toFixed(1)}</td>
                  </tr>`,
              )
              .join('')}
          </tbody>
        </table>`;
      container.innerHTML = html;
    }

    function renderDataTable() {
      const seen = new Set();
      const dataset = filteredData
        .filter((row, index) => {
          const key = `${row['Call ID'] || '__missing'}|${row.CallTime || row.Date || index}`;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        })
        .sort((a, b) => {
          const parseDate = (value) => {
            const date = value ? new Date(value) : null;
            return date instanceof Date && !Number.isNaN(date) ? date.getTime() : -Infinity;
          };
          return parseDate(b.CallTime ?? b.Date) - parseDate(a.CallTime ?? a.Date);
        });

      if (!dataset.length) {
        dataTable.innerHTML = '<p class="muted">Aucune donnée à afficher.</p>';
        return;
      }
      const headers = [
        'Call ID',
        'Call Time',
        'From',
        'To',
        'Direction',
        'Status',
        'AgentLabel',
        'AgentExt',
        'AgentTracked',
        'ExtensionCategory',
        'QueueLabel',
        'QueueNumber',
        'QueueGroup',
        'QueueAssociated',
        'CallType',
        'TalkingSeconds',
        'RingingSeconds',
      ];
      const html = `
        <table>
          <thead>
            <tr>${headers.map((h) => `<th>${h}</th>`).join('')}</tr>
          </thead>
          <tbody>
            ${dataset
              .slice(0, 400)
              .map(
                (row) => `
                  <tr>
                    ${headers
                      .map((h) => `<td>${row[h] ?? row[`${h}Clean`] ?? ''}</td>`)
                      .join('')}
                  </tr>`,
              )
              .join('')}
          </tbody>
        </table>
        <p class="muted">${dataset.length > 400 ? 'Affichage limité aux 400 premières lignes pour garder de bonnes performances.' : ''}</p>`;
      dataTable.innerHTML = html;
    }

    function renderCharts() {
      const byDate = {};
      const byHour = Array(24).fill(0);

      callAggregates.forEach((row) => {
        if (row.date) byDate[row.date] = (byDate[row.date] || 0) + 1;
        if (row.hour !== '' && row.hour !== null && row.hour !== undefined) byHour[Number(row.hour)] += 1;
      });

      const dateLabels = Object.keys(byDate).sort((a, b) => new Date(a) - new Date(b));
      const formattedDateLabels = dateLabels.map((d) => formatChartDateLabel(d));
      createChart('date-chart', 'bar', {
        labels: formattedDateLabels,
        datasets: [{ label: 'Appels', data: dateLabels.map((d) => byDate[d]), backgroundColor: '#22c55e' }],
      });

      createChart('hour-chart', 'bar', {
        labels: Array.from({ length: 24 }, (_, i) => `${i}h`),
        datasets: [{ label: 'Appels', data: byHour, backgroundColor: '#22c55e' }],
      });
    }

    function createChart(id, type, data) {
      const ctx = document.getElementById(id);
      if (charts[id]) charts[id].destroy();
      charts[id] = new Chart(ctx, {
        type,
        data,
        options: { responsive: true, plugins: { legend: { display: false } } },
      });
    }

    function formatChartDateLabel(value) {
      if (!value) return '';
      const date = new Date(value);
      if (!(date instanceof Date) || Number.isNaN(date)) return value;
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}:${month}:${year}`;
    }

    function switchTab(target) {
      tabButtons.forEach((btn) => btn.classList.toggle('active', btn.dataset.tabTarget === target));
      tabSections.forEach((section) => section.classList.toggle('active', section.dataset.tab === target));
    }

    function loadImportLog() {
      const stored = localStorage.getItem('import-log');
      if (!stored) return [];
      try {
        return JSON.parse(stored);
      } catch (e) {
        console.error("Impossible de lire l'historique des imports", e);
        return [];
      }
    }

    function saveImportLog() {
      localStorage.setItem('import-log', JSON.stringify(importLog));
    }

    function formatDate(value) {
      if (!value) return '';
      const date = new Date(value);
      return date instanceof Date && !Number.isNaN(date) ? date.toLocaleString('fr-FR') : '';
    }

    function addImportEntry(importId, fileName, importedAt, rows) {
      if (!rows.length) return;
      const dates = rows
        .map((row) => row.CallTime instanceof Date ? row.CallTime : row.CallTime ? new Date(row.CallTime) : row.Date ? new Date(row.Date) : null)
        .filter((d) => d instanceof Date && !Number.isNaN(d));
      const start = dates.length ? new Date(Math.min(...dates)) : null;
      const end = dates.length ? new Date(Math.max(...dates)) : null;
      importLog.push({
        id: importId,
        fileName,
        importedAt,
        startDate: start ? start.toISOString() : '',
        endDate: end ? end.toISOString() : '',
        rows: rows.length,
      });
      saveImportLog();
      renderImportList();
    }

    function renderImportList() {
      if (!importLog.length) {
        importList.textContent = 'Aucun import enregistré.';
        return;
      }
      const rows = importLog
        .map(
          (entry) => `
            <tr>
              <td>${entry.fileName}</td>
              <td>${formatDate(entry.importedAt)}</td>
              <td>${entry.startDate ? formatDate(entry.startDate) : 'N/A'}</td>
              <td>${entry.endDate ? formatDate(entry.endDate) : 'N/A'}</td>
              <td>${entry.rows}</td>
              <td style="text-align:center"><button data-delete-import="${entry.id}" aria-label="Supprimer l'import" style="width:auto;padding:0.35rem 0.55rem;">✕</button></td>
            </tr>
          `,
        )
        .join('');

      importList.innerHTML = `
        <table>
          <thead>
            <tr>
              <th>Fichier</th>
              <th>Date d'import</th>
              <th>Période minimale</th>
              <th>Période maximale</th>
              <th>Lignes gardées</th>
              <th></th>
            </tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      `;

      importList.querySelectorAll('[data-delete-import]').forEach((btn) => {
        btn.addEventListener('click', () => removeImport(btn.dataset.deleteImport));
      });
    }

    async function removeImport(importId) {
      importLog = importLog.filter((entry) => entry.id !== importId);
      rawData = rawData.filter((row) => row.ImportId !== importId);
      await persistDataset(rawData);
      saveImportLog();
      renderImportList();
      populateFilters(rawData);
      applyFilters();
      fileSummary.textContent = rawData.length
        ? `${rawData.length} lignes restantes après suppression.`
        : 'Aucun fichier chargé.';
    }

    function exportFiltered() {
      const dataset = filteredData;
      if (!dataset.length) return alert('Aucune donnée filtrée à exporter.');
      const headers = Object.keys(dataset[0]);
      const csv = [headers.join(',')].concat(
        dataset.map((row) => headers.map((h) => JSON.stringify(row[h] ?? '')).join(',')),
      );
      const blob = new Blob([csv.join('\n')], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'appels_filtrés.csv';
      a.click();
      URL.revokeObjectURL(url);
    }

    importLog = loadImportLog();
    renderImportList();
    switchTab('pilotage');
    restoreFromIndexedDB();
  </script>
</body>
</html>
