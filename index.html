<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Analyse des appels 3CX</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-o9N1j7kP6+R2zHob6hJ0u06tR7cqp2p3p3p3v5A4o="
    crossorigin=""
  />
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-o9N1j7kP6+R2zHob6hJ0u06tR7cqp2p3p3p3v5A4o="
    crossorigin=""
  ></script>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0f172a;
      --card: #1e293b;
      --border: #334155;
      --text: #e2e8f0;
      --accent: #22c55e;
      --muted: #94a3b8;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
    }
    header {
      padding: 1.5rem 2rem;
      border-bottom: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.9);
      position: sticky;
      top: 0;
      backdrop-filter: blur(8px);
      z-index: 10;
    }
    nav.tabs {
      display: flex;
      gap: 0.75rem;
      padding: 0 2rem 1rem;
      border-bottom: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.85);
      position: sticky;
      top: 78px;
      z-index: 9;
      backdrop-filter: blur(8px);
    }
    .tab-button {
      padding: 0.65rem 1.1rem;
      border-radius: 10px;
      background: #0b1221;
      border: 1px solid var(--border);
      color: var(--text);
      font-weight: 700;
      cursor: pointer;
      transition: all 0.15s ease;
    }
    .tab-button.active {
      background: var(--accent);
      color: #06240d;
      border-color: var(--accent);
    }
    .brand { display: flex; align-items: center; gap: 1rem; }
    h1 { margin: 0 0 0.3rem; font-size: 1.8rem; }
    p.subtitle { margin: 0; color: var(--muted); }
    main { padding: 1.5rem 2rem 3rem; display: grid; gap: 1rem; }
    section { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 1rem 1.25rem; }
    h2 { margin-top: 0; }
    .grid { display: grid; gap: 1rem; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); }
    .controls { display: flex; gap: 0.75rem; flex-wrap: wrap; }
    .filters-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 0.75rem;
    }
    .filters-grid + .filters-grid { margin-top: 0.75rem; }
    .chip {
      background: #0b1221;
      border: 1px solid var(--border);
      padding: 0.6rem 0.9rem;
      border-radius: 10px;
      flex: 1;
      min-width: 220px;
    }
    label { display: block; margin-bottom: 0.4rem; font-weight: 600; }
    input, select, button {
      width: 100%;
      padding: 0.65rem 0.75rem;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #0b1221;
      color: var(--text);
    }
    button.primary {
      background: var(--accent);
      color: #06240d;
      font-weight: 700;
      border: none;
      cursor: pointer;
      transition: transform 0.1s ease;
    }
    button.primary:active { transform: translateY(1px); }
    textarea {
      width: 100%;
      min-height: 110px;
      padding: 0.65rem 0.75rem;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #0b1221;
      color: var(--text);
      resize: vertical;
    }
    .dropzone {
      border: 1.5px dashed var(--border);
      border-radius: 12px;
      padding: 1rem;
      text-align: center;
      background: #0b1221;
      cursor: pointer;
    }
    .dropzone:hover { border-color: var(--accent); }
    .dropzone.dragging {
      border-color: var(--accent);
      background: rgba(34, 197, 94, 0.05);
    }
    .kpi-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(220px, 1fr));
      gap: 0.9rem;
    }
    .kpi { padding: 0.8rem; border-radius: 10px; border: 1px solid var(--border); background: #0b1221; }
    .kpi .label { color: var(--muted); font-size: 0.9rem; }
    .kpi .value { font-size: 1.4rem; font-weight: 700; margin-top: 0.2rem; }
    table { width: 100%; border-collapse: collapse; margin-top: 0.5rem; }
    th, td { padding: 0.55rem 0.65rem; text-align: left; border-bottom: 1px solid var(--border); }
    th { color: var(--muted); font-weight: 700; }
    tbody tr:hover { background: rgba(255, 255, 255, 0.03); }
    .muted { color: var(--muted); }
    .badge { padding: 0.2rem 0.45rem; border-radius: 6px; font-weight: 700; font-size: 0.85rem; }
    .badge.success { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
    .badge.warn { background: rgba(234, 179, 8, 0.15); color: #fbbf24; }
    .actions { display: flex; gap: 0.75rem; flex-wrap: wrap; }
    .chart-wrapper { position: relative; height: 260px; }
    .stats-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; }
    .stats-row + .stats-row {
      margin-top: 1.5rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border);
    }
    .stats-row.stats-charts { padding-top: 1.25rem; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    .map-card { background: #0b1221; border: 1px solid var(--border); border-radius: 12px; padding: 0.5rem; }
    #ville92-map { width: 100%; height: 520px; border-radius: 8px; }
    .legend { display: flex; align-items: center; gap: 0.5rem; color: var(--muted); margin-top: 0.5rem; flex-wrap: wrap; }
    .legend span { display: inline-flex; align-items: center; gap: 0.35rem; }
    .legend .swatch { width: 18px; height: 10px; border-radius: 4px; display: inline-block; border: 1px solid var(--border); }
    .ville92-actions { display: flex; gap: 0.75rem; flex-wrap: wrap; align-items: flex-end; }
    .ville92-actions button { width: auto; }
    .ville92-table { width: 100%; border-collapse: collapse; margin-top: 0.75rem; }
    .ville92-table th, .ville92-table td { padding: 0.5rem 0.65rem; border-bottom: 1px solid var(--border); text-align: left; }
    .ville92-table th { color: var(--muted); font-weight: 700; }
    .ville92-error { color: #f87171; margin: 0.35rem 0 0; }
    @media (max-width: 820px) { .brand { flex-direction: column; align-items: flex-start; } }
    @media (max-width: 780px) { .kpi-grid { grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); } }
    @media (max-width: 680px) { header { position: static; } }
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <div>
        <h1>Analyse des appels 3CX</h1>
        <p class="subtitle">Chargez vos fichiers CSV, analysez hors-ligne, exportez et sauvegardez vos données directement dans le navigateur.</p>
      </div>
    </div>
  </header>

  <nav class="tabs">
    <button class="tab-button active" data-tab-target="pilotage">Pilotage</button>
    <button class="tab-button" data-tab-target="import">Import</button>
    <button class="tab-button" data-tab-target="ville92">Ville 92</button>
  </nav>

  <main>
    <section class="tab-content" data-tab="import">
      <h2>Importer les CSV</h2>
      <div class="grid">
        <label class="dropzone">
            <input id="file-input" type="file" accept=".csv" multiple style="display:none" />
            Glissez-déposez vos fichiers CSV ici ou cliquez pour les sélectionner (les données restent sur votre machine).
        </label>
        <div class="chip">
          <label>Sauvegarde automatique</label>
          <div class="actions">
            <button id="clear-local" type="button">Effacer la sauvegarde locale</button>
          </div>
          <p id="save-status" class="muted" style="margin-top:0.5rem">Aucune sauvegarde locale pour le moment.</p>
        </div>
      </div>
      <p id="file-summary" class="muted" style="margin-top:0.5rem">Aucun fichier chargé.</p>
      <div id="imports-panel" style="margin-top:1rem" class="chip">
        <h3 style="margin-top:0;">Imports précédents</h3>
        <div id="import-list" class="muted">Aucun import enregistré.</div>
      </div>
    </section>

    <section class="tab-content" data-tab="pilotage">
      <h2>Filtres</h2>
      <div class="filters-grid">
        <div class="chip">
          <label for="direction-select">Direction</label>
          <select id="direction-select" multiple size="4"></select>
        </div>
        <div class="chip">
          <label for="status-select">Statut</label>
          <select id="status-select" multiple size="4"></select>
        </div>
        <div class="chip">
          <label for="agent-select">Utilisateurs</label>
          <select id="agent-select" multiple size="6"></select>
        </div>
        <div class="chip">
          <label for="queue-select">Files d'attente</label>
          <select id="queue-select" multiple size="6"></select>
        </div>
      </div>
      <div class="filters-grid">
        <div class="chip">
          <label>Période</label>
          <div class="controls" style="padding:0; gap:0.35rem; flex-wrap:nowrap;">
            <input id="start-date" type="date" />
            <input id="end-date" type="date" />
          </div>
        </div>
        <div class="chip">
          <label>Horaires (heures)</label>
          <div class="controls" style="padding:0; gap:0.35rem; flex-wrap:nowrap;">
            <input id="start-hour" type="number" min="0" max="23" step="1" />
            <input id="end-hour" type="number" min="0" max="23" step="1" />
          </div>
        </div>
        <div class="chip" style="align-self:flex-end">
          <button id="apply-filters" class="primary" type="button">Appliquer les filtres</button>
        </div>
      </div>
    </section>

    <section class="tab-content" data-tab="pilotage">
      <h2>Indicateurs clés</h2>
      <div class="kpi-grid" id="kpi-container"></div>
    </section>

    <section class="tab-content" data-tab="pilotage">
      <h2>Statistiques</h2>
      <div class="stats-row">
        <div>
          <h3>Standard</h3>
          <div id="standard-stats"></div>
        </div>
        <div>
          <h3>Files d'attente</h3>
          <div id="queue-stats"></div>
        </div>
      </div>
      <div class="stats-row stats-charts">
        <div>
          <h3>Répartition des appels par jour</h3>
          <div class="chart-wrapper"><canvas id="date-chart"></canvas></div>
        </div>
        <div>
          <h3>Répartition des appels par heure</h3>
          <div class="chart-wrapper"><canvas id="hour-chart"></canvas></div>
        </div>
      </div>
    </section>

    <section class="tab-content" data-tab="pilotage">
      <h2>Données</h2>
      <div class="actions" style="margin-bottom:0.5rem">
        <button id="export-btn" type="button">Exporter la sélection (CSV)</button>
      </div>
      <div id="data-table"></div>
    </section>

    <section class="tab-content" data-tab="ville92">
      <h2>Ville 92</h2>
      <p class="muted">
        Analyse des événements <code>trafic_changement_carte_92_events</code> : taux d'ouverture/fermeture par commune
        des Hauts-de-Seine (92).
      </p>
      <div class="grid">
        <div class="chip">
          <label for="ville92-file">Importer un CSV trafic_changement_carte_92</label>
          <input id="ville92-file" type="file" accept=".csv" />
          <p class="muted" style="margin:0.5rem 0 0" id="ville92-import-status">Aucun événement importé.</p>
        </div>
        <div class="chip">
          <label>Filtrer la période (Europe/Paris)</label>
          <div class="filters-grid" style="padding:0">
            <div>
              <label for="ville92-start-date">Date de début</label>
              <input id="ville92-start-date" type="date" required />
            </div>
            <div>
              <label for="ville92-end-date">Date de fin</label>
              <input id="ville92-end-date" type="date" required />
            </div>
            <div>
              <label for="ville92-start-time">Heure de début</label>
              <input id="ville92-start-time" type="time" value="00:00" />
            </div>
            <div>
              <label for="ville92-end-time">Heure de fin</label>
              <input id="ville92-end-time" type="time" value="23:59" />
            </div>
          </div>
          <div class="ville92-actions">
            <button id="ville92-apply" class="primary" type="button">Appliquer</button>
            <button id="ville92-reset" type="button">Réinitialiser</button>
            <span id="ville92-error" class="ville92-error"></span>
          </div>
        </div>
      </div>

      <div class="map-card" style="margin-top:1rem">
        <div id="ville92-map"></div>
        <div class="legend" id="ville92-legend" aria-label="Légende des couleurs"></div>
      </div>

      <div id="ville92-summary" style="margin-top:1rem"></div>
      <div id="ville92-unmatched" class="muted"></div>
    </section>
  </main>

  <script>
    const fileInput = document.getElementById('file-input');
    const fileSummary = document.getElementById('file-summary');
    const directionSelect = document.getElementById('direction-select');
    const statusSelect = document.getElementById('status-select');
    const agentSelect = document.getElementById('agent-select');
    const queueSelect = document.getElementById('queue-select');
    const startDateInput = document.getElementById('start-date');
    const endDateInput = document.getElementById('end-date');
    const startHourInput = document.getElementById('start-hour');
    const endHourInput = document.getElementById('end-hour');
    const tabButtons = document.querySelectorAll('.tab-button');
    const tabSections = document.querySelectorAll('.tab-content');
    const kpiContainer = document.getElementById('kpi-container');
    const standardStats = document.getElementById('standard-stats');
    const queueStats = document.getElementById('queue-stats');
    const dataTable = document.getElementById('data-table');
    const saveStatus = document.getElementById('save-status');
    const importList = document.getElementById('import-list');
    const ville92FileInput = document.getElementById('ville92-file');
    const ville92ImportStatus = document.getElementById('ville92-import-status');
    const ville92StartDateInput = document.getElementById('ville92-start-date');
    const ville92EndDateInput = document.getElementById('ville92-end-date');
    const ville92StartTimeInput = document.getElementById('ville92-start-time');
    const ville92EndTimeInput = document.getElementById('ville92-end-time');
    const ville92ApplyBtn = document.getElementById('ville92-apply');
    const ville92ResetBtn = document.getElementById('ville92-reset');
    const ville92Error = document.getElementById('ville92-error');
    const ville92Summary = document.getElementById('ville92-summary');
    const ville92Unmatched = document.getElementById('ville92-unmatched');
    const ville92Legend = document.getElementById('ville92-legend');

    const TRACKED_EXTENSIONS = [
      { ext: '100', name: 'Abder Amazit' },
      { ext: '101', name: 'Ines Rodrigues' },
      { ext: '102', name: 'Imène Dikhissi' },
      { ext: '103', name: 'Bérangère Bai' },
      { ext: '104', name: 'Bassi Ouled Beidou' },
      { ext: '105', name: 'Christelle Vigee' },
      { ext: '106', name: 'Katia Raini' },
      { ext: '107', name: 'Compte en attente (1)' },
      { ext: '108', name: 'Mariam Chafai' },
      { ext: '109', name: 'Mariama Gassama' },
      { ext: '110', name: 'Mayana Augustin' },
      { ext: '111', name: 'Myreille Noel' },
      { ext: '112', name: 'Myriam Chenaf' },
      { ext: '113', name: 'Nathalie Beaussart' },
      { ext: '114', name: 'Sabrina Meskine' },
      { ext: '115', name: 'Sandrine Semedo Gonçalves' },
      { ext: '116', name: 'Salma Meskine' },
      { ext: '117', name: 'Extension 117' },
      { ext: '118', name: 'Mael Cosnet' },
      { ext: '119', name: 'Extension 119' },
      { ext: '120', name: 'Extension 120' },
      { ext: '121', name: 'Extension 121' },
      { ext: '122', name: 'Extension 122' },
      { ext: '123', name: 'Reynald Celini' },
      { ext: '124', name: 'Maud Autonomis' },
      { ext: '125', name: 'Hanane Abbadi' },
      { ext: '126', name: 'Aéline Njem belle Ekwe' },
      { ext: '127', name: 'Autonomis 1' },
      { ext: '128', name: 'Autonomis 2' },
      { ext: '129', name: 'Extension 129' },
      { ext: '130', name: 'Extension 130' },
    ];

    const TRACKED_QUEUES = [
      { number: '800', label: 'Annulation', group: 'Standard', associated: '0146037744 (SVI – ligne patient)' },
      { number: '801', label: 'Visite_Dom', group: 'Standard', associated: '0146037744 (SVI – ligne patient)' },
      { number: '802', label: 'Consult_Teleconsult', group: 'Standard', associated: '0146037744 (SVI – ligne patient)' },
      { number: '803', label: 'Demande_Admin', group: 'Standard', associated: '0146037744 (SVI – ligne patient)' },
      { number: '804', label: 'Medecin', group: 'Standard', associated: '146032345 (Medecin)' },
      { number: '805', label: 'Autonomis', group: 'Autonomis', associated: '973793043 (Ligne AUTONOMIS)' },
      { number: '806', label: 'Sobel', group: 'SOS92', associated: '146032369 (Sobel)' },
      { number: '807', label: 'Samu', group: '—', associated: '146032110 (Samu)' },
      { number: '808', label: 'RH', group: '—', associated: '146037678' },
      { number: '809', label: 'Prioritaire', group: 'N/C', associated: '—' },
      { number: '810', label: 'Assistance (Med evasan)', group: 'Standard', associated: '146038538' },
      { number: '811', label: 'FERMETURE CP (Répondeur numérique)', group: 'N/C', associated: '—' },
      { number: '812', label: 'Dr. Bolourian', group: 'Standard', associated: 'N/C' },
      { number: '880', label: 'demo', group: '—', associated: '146037577' },
    ];

    const trackedExtensionMap = new Map(TRACKED_EXTENSIONS.map((entry) => [entry.ext, entry.name]));
    const trackedQueueMap = new Map(TRACKED_QUEUES.map((entry) => [entry.number, entry]));
    const QUEUE_EXTENSION_RANGE = { start: 800, end: 880 };

    for (let number = QUEUE_EXTENSION_RANGE.start; number <= QUEUE_EXTENSION_RANGE.end; number += 1) {
      const key = String(number);
      if (!trackedQueueMap.has(key)) {
        trackedQueueMap.set(key, { number: key, label: `File ${key}`, group: '—', associated: '—' });
      }
    }

    const DIRECTION_LABELS = {
      inbound: 'Appel entrant',
      outbound: 'Appel sortant',
      'inbound queue': 'Passage en file',
      internal: 'Appel interne',
    };

    const STATUS_LABELS = {
      answered: 'Répondu',
      unanswered: 'Non répondu',
      busy: 'Occupé',
      failed: 'Échec',
      waiting: 'En attente',
    };

    function normalizeStatus(value) {
      return (value || '').toString().trim().toLowerCase();
    }

    let rawData = [];
    let filteredData = [];
    let eligibleData = [];
    let standardEligibleData = [];
    let callSummaries = [];
    let callAggregates = [];
    let failedCallAggregates = [];
    let outboundFailureAggregates = [];
    let extensionAggregates = { standard: [], medecin: [], queue: [], other: [] };
    let charts = {};
    let importLog = [];
    let selectedDate = null;
    let carte92Events = [];
    let carte92Geojson = null;
    let ville92Map = null;
    let ville92Layer = null;
    let ville92LastMetrics = null;
    let ville92Filters = { startDate: '', endDate: '', startTime: '00:00', endTime: '23:59' };

    const DB_NAME = 'appels3cx-db';
    const DB_VERSION = 1;
    const DB_STORE = 'calls';

    fileInput.addEventListener('change', (event) => handleFiles(event.target.files));
    document.getElementById('apply-filters').addEventListener('click', applyFilters);
    document.getElementById('export-btn').addEventListener('click', exportFiltered);
    document.getElementById('clear-local').addEventListener('click', clearIndexedDB);
    tabButtons.forEach((btn) => btn.addEventListener('click', () => switchTab(btn.dataset.tabTarget)));
    ville92FileInput?.addEventListener('change', (event) => handleCarte92Files(event.target.files));
    ville92ApplyBtn?.addEventListener('click', applyVille92Filters);
    ville92ResetBtn?.addEventListener('click', resetVille92Filters);

    const dropzone = document.querySelector('.dropzone');
    dropzone.addEventListener('click', () => fileInput.click());
    dropzone.addEventListener('dragover', (event) => {
      event.preventDefault();
      dropzone.classList.add('dragging');
    });
    dropzone.addEventListener('dragleave', () => dropzone.classList.remove('dragging'));
    dropzone.addEventListener('drop', (event) => {
      event.preventDefault();
      dropzone.classList.remove('dragging');
      handleFiles(event.dataTransfer.files);
    });

    function openDatabase() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(DB_STORE)) {
            db.createObjectStore(DB_STORE, { keyPath: 'id', autoIncrement: true });
          }
        };

        request.onsuccess = (event) => resolve(event.target.result);
        request.onerror = (event) => reject(event.target.error);
      });
    }

    async function persistDataset(rows) {
      try {
        const db = await openDatabase();
        await new Promise((resolve, reject) => {
          const tx = db.transaction(DB_STORE, 'readwrite');
          const store = tx.objectStore(DB_STORE);
          store.clear();
          rows.forEach((row) => {
            const { id: _ignored, ...payload } = row;
            store.add(payload);
          });
          tx.oncomplete = resolve;
          tx.onerror = () => reject(tx.error);
        });
        saveStatus.textContent = 'Données sauvegardées automatiquement dans le navigateur.';
      } catch (error) {
        console.error('Impossible de sauvegarder localement', error);
        saveStatus.textContent = "Échec de la sauvegarde locale. Les données restent en mémoire vive.";
      }
    }

    async function restoreFromIndexedDB() {
      try {
        const db = await openDatabase();
        const rows = await new Promise((resolve, reject) => {
          const result = [];
          const tx = db.transaction(DB_STORE, 'readonly');
          const store = tx.objectStore(DB_STORE);
          const cursorReq = store.openCursor();
          cursorReq.onsuccess = (event) => {
            const cursor = event.target.result;
            if (cursor) {
              const { id: _ignored, ...payload } = cursor.value;
              result.push(payload);
              cursor.continue();
            } else {
              resolve(result);
            }
          };
          cursorReq.onerror = () => reject(cursorReq.error);
        });

        if (rows.length) {
          rawData = rows;
          fileSummary.textContent = `Données restaurées depuis la sauvegarde locale – ${rawData.length} lignes.`;
          populateFilters(rawData);
          applyFilters();
          saveStatus.textContent = 'Données chargées depuis la sauvegarde locale.';
        }
      } catch (error) {
        console.error('Lecture de la sauvegarde locale impossible', error);
      }
    }

    async function clearIndexedDB() {
      await new Promise((resolve, reject) => {
        const req = indexedDB.deleteDatabase(DB_NAME);
        req.onsuccess = resolve;
        req.onerror = () => reject(req.error);
      });
      rawData = [];
      filteredData = [];
      standardEligibleData = [];
      callSummaries = [];
      callAggregates = [];
      failedCallAggregates = [];
      outboundFailureAggregates = [];
      extensionAggregates = { standard: [], medecin: [], queue: [], other: [] };
      dataTable.innerHTML = '';
      kpiContainer.innerHTML = '';
      standardStats.innerHTML = '';
      queueStats.innerHTML = '';
      fileSummary.textContent = 'Sauvegarde supprimée.';
      saveStatus.textContent = 'Aucune sauvegarde locale pour le moment.';
      importLog = [];
      localStorage.removeItem('import-log');
      renderImportList();
    }

    function handleFiles(files) {
      if (!files || !files.length) return;
      const imports = Array.from(files).map((file) =>
        parseFile(file)
          .then((rows) => ({ rows, fileName: file.name }))
          .catch((err) => {
            console.error(err);
            return { rows: [], fileName: file.name, error: true };
          }),
      );

      Promise.all(imports)
        .then(async (items) => {
          for (const item of items) {
            if (item.error) continue;
            await ingestRows(item.rows, item.fileName);
          }
        })
        .catch((err) => {
          console.error(err);
          fileSummary.textContent = "Erreur lors du chargement des fichiers.";
        });
    }

    async function ingestRows(rows, fileName) {
      if (!rows || !rows.length) {
        fileSummary.textContent = `${fileName} – aucune ligne détectée.`;
        return;
      }
      const importId = crypto.randomUUID ? crypto.randomUUID() : `imp_${Date.now()}_${Math.random().toString(16).slice(2)}`;
      const importedAt = new Date().toISOString();
      const taggedRows = rows.map((row) => ({ ...row, __importId: importId, __fileName: fileName, __importedAt: importedAt }));

      const merged = rawData.concat(taggedRows);
      const { rows: cleaned, duplicates } = buildDataset(merged);
      rawData = cleaned;
      const duplicateNote = duplicates
        ? ` (${duplicates} doublon(s) ignoré(s) sur ${merged.length} lignes chargées)`
        : '';
      fileSummary.textContent = `${fileName} – ${rawData.length} lignes après nettoyage${duplicateNote}.`;
      const importRows = rawData.filter((row) => row.ImportId === importId);
      addImportEntry(importId, fileName, importedAt, importRows);
      await persistDataset(rawData);
      populateFilters(rawData);
      applyFilters();
    }

    function parseFile(file) {
      return new Promise((resolve, reject) => {
        Papa.parse(file, {
          header: true,
          skipEmptyLines: true,
          complete: (results) => resolve(results.data),
          error: reject,
        });
      });
    }

    function normalizeKey(key) {
      return String(key || '')
        .replace(/^\ufeff+/, '')
        .trim()
        .normalize('NFKD')
        .replace(/[\u0300-\u036f]/g, '')
        .toLowerCase()
        .replace(/\s+/g, ' ');
    }

    function normalizeRecord(record) {
      const normalized = {};
      Object.entries(record || {}).forEach(([key, value]) => {
        const normalizedKey = normalizeKey(key);
        normalized[normalizedKey] = typeof value === 'string' ? value.trim() : value;
      });
      return normalized;
    }

    function readField(record, candidates, fallback = '') {
      for (const candidate of candidates) {
        const normalizedKey = normalizeKey(candidate);
        if (record.hasOwnProperty(normalizedKey)) return record[normalizedKey];
      }
      return fallback;
    }

    function convertDuration(value) {
      if (value === null || value === undefined || value === '') return 0;
      if (typeof value === 'number') return value;
      const text = String(value).trim();
      const match = text.match(/^(\d+):(\d{1,2})(?::(\d{1,2})(?:\.\d+)?)?$/);
      if (match) {
        const [, a, b, c] = match;
        const hours = c !== undefined ? Number(a) : 0;
        const minutes = c !== undefined ? Number(b) : Number(a);
        const seconds = c !== undefined ? Number(c) : Number(b);
        return hours * 3600 + minutes * 60 + seconds;
      }
      const numeric = Number(text.replace(',', '.'));
      return Number.isFinite(numeric) ? numeric : 0;
    }

    const trackedExtensionNumbers = TRACKED_EXTENSIONS.map((entry) => entry.ext);
    const trackedQueueNumbers = Array.from(trackedQueueMap.keys());

    function extractAgent(direction, from, to) {
      const regex = /([^()]+?)\s*\((\d{2,})\)/;
      const dir = (direction || '').toLowerCase();
      const candidates = dir.includes('outbound')
        ? [{ value: from, source: 'from' }]
        : dir.includes('inbound')
          ? [{ value: to, source: 'to' }]
          : [
              { value: from, source: 'from' },
              { value: to, source: 'to' },
            ];

      for (const candidate of candidates) {
        const match = regex.exec(candidate.value || '');
        if (match) {
          return { name: match[1].trim(), ext: match[2], source: candidate.source };
        }
      }
      return { name: '', ext: '', source: '' };
    }

    function findTrackedExtension(...fields) {
      for (const field of fields) {
        const text = (field || '').toString();
        for (const ext of trackedExtensionNumbers) {
          const regex = new RegExp(`\\b${ext}\\b`);
          if (regex.test(text)) return ext;
        }
      }
      return '';
    }

    function findTrackedQueue(...fields) {
      for (const field of fields) {
        const text = (field || '').toString();
        for (const number of trackedQueueNumbers) {
          const regex = new RegExp(`\\b${number}\\b`);
          if (regex.test(text)) {
            if (number === '992') return null;
            return trackedQueueMap.get(number);
          }
        }
      }
      return null;
    }

    function classifyExtension(ext) {
      const value = Number(ext);
      if (Number.isFinite(value) && value >= 100 && value <= 130) return 'standard';
      if (Number.isFinite(value) && value >= 132 && value <= 345) return 'medecin';
      if (Number.isFinite(value) && value >= 800) return 'queue';
      return 'other';
    }

    function categorizeCall(direction, to, details) {
      const dir = (direction || '').trim().toLowerCase();
      const toText = (to || '').toLowerCase();
      const detailText = (details || '').toLowerCase();
      if (toText.includes('voicemail') || detailText.includes('voicemail')) return 'Voicemail';
      if (toText.includes('script') || detailText.includes('call script')) return 'Script';
      if (['inbound', 'outbound', 'internal'].includes(dir)) return dir.charAt(0).toUpperCase() + dir.slice(1);
      return 'Autre';
    }

    function isCallScript(row) {
      return (row?.CallType || '').toLowerCase() === 'script';
    }

    function isoWeek(date) {
      const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
      const dayNum = d.getUTCDay() || 7;
      d.setUTCDate(d.getUTCDate() + 4 - dayNum);
      const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
      return Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
    }

    function parseDateTime(value) {
      if (!value) return null;
      if (value instanceof Date && !Number.isNaN(value)) return value;
      if (typeof value === 'number') {
        const excel = new Date(Math.round((value - 25569) * 86400 * 1000));
        if (!Number.isNaN(excel)) return excel;
      }
      const text = String(value).trim();
      const direct = Date.parse(text);
      if (!Number.isNaN(direct)) return new Date(direct);

      const ampmMatch = text.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})\s+(\d{1,2}):(\d{2})(?::(\d{2}))?\s*(AM|PM)$/i);
      if (ampmMatch) {
        const [, d, m, y, hh, mm, ss = '0', suffix] = ampmMatch;
        const year = y.length === 2 ? 2000 + Number(y) : Number(y);
        let hours = Number(hh) % 12;
        if (suffix.toUpperCase() === 'PM') hours += 12;
        return new Date(year, Number(m) - 1, Number(d), hours, Number(mm), Number(ss));
      }

      const match = text.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})(?:\s+(\d{1,2}):(\d{2})(?::(\d{2}))?)?$/);
      if (match) {
        const [, d, m, y, hh = '0', mm = '0', ss = '0'] = match;
        const year = y.length === 2 ? 2000 + Number(y) : Number(y);
        return new Date(year, Number(m) - 1, Number(d), Number(hh), Number(mm), Number(ss));
      }
      return null;
    }

    function buildDataset(rows) {
      const occurrences = new Map();
      const cleanedRows = [];
      let duplicateCounter = 0;

      rows.forEach((row) => {
        const normalized = normalizeRecord(row);
        const callTimeRaw = readField(normalized, ['Call Time', 'Call Start Time', 'Start Time', 'Date', 'Date/Heure', 'Debut']);
        const from = readField(normalized, ['From', 'De', 'Origine']);
        const to = readField(normalized, ['To', 'Vers', 'Destinataire']);
        const direction = readField(normalized, ['Direction', 'Sens']);
        const status = readField(normalized, ['Status', 'Statut']);
        const ringing = readField(normalized, ['Ringing', 'Sonnerie']);
        const talking = readField(normalized, ['Talking', 'Parole', 'Conversation']);
        const callId = readField(normalized, ['Call ID', 'ID', 'ID Appel']);
        const details = readField(normalized, ['Call Activity Details', 'Details']);

        const callTime = parseDateTime(callTimeRaw);
        const agent = extractAgent(direction, from, to);
        const queueInfo = findTrackedQueue(from, to, details);
        const extension = agent.ext;
        const agentName = agent.name || trackedExtensionMap.get(extension) || '';
        const extensionCategory = classifyExtension(extension);
        const isInbound = (direction || '').toLowerCase().includes('inbound');
        const isOutbound = (direction || '').toLowerCase().includes('outbound');
        const directionAligned =
          (isOutbound && agent.source === 'from') ||
          (isInbound && agent.source === 'to') ||
          (!isInbound && !isOutbound && !!extension);
        const record = {
          'Call ID': callId,
          'Call Time': callTimeRaw,
          From: from,
          To: to,
          Direction: direction,
          Status: status,
          'Call Activity Details': details,
          AgentName: agentName || agent.name,
          AgentLabel: extension
            ? `${extension} – ${agentName || agent.name || 'Extension inconnue'}`
            : agentName || agent.name,
          AgentExt: extension,
          AgentTracked: Boolean(extension && trackedExtensionMap.has(extension)),
          ExtensionCategory: extensionCategory,
          AgentDirectionMatch: directionAligned,
          QueueNumber: queueInfo?.number || '',
          QueueLabel: queueInfo?.label || '',
          QueueGroup: queueInfo?.group || queueInfo?.label || '',
          QueueAssociated: queueInfo?.associated || '',
          QueueTracked: Boolean(queueInfo),
          RingingSeconds: convertDuration(ringing),
          TalkingSeconds: convertDuration(talking),
          DirectionClean: (direction || '').toString().trim(),
          StatusClean: (status || '').toString().trim(),
          CallTime: callTime,
          Date: callTime ? callTime.toISOString().slice(0, 10) : '',
          Year: callTime ? callTime.getFullYear() : '',
          Month: callTime ? callTime.getMonth() + 1 : '',
          Week: callTime ? isoWeek(callTime) : '',
          DayOfWeek: callTime ? callTime.toLocaleDateString('fr-FR', { weekday: 'long' }) : '',
          Hour: callTime ? callTime.getHours() : '',
          ImportId: row.__importId || '',
          ImportFileName: row.__fileName || '',
          ImportedAt: row.__importedAt || '',
        };
        record.CallType = categorizeCall(record.DirectionClean, record.To, record['Call Activity Details']);

        const callTimeKey = record.CallTime instanceof Date
          ? record.CallTime.toISOString()
          : (record.CallTime || '');
        const key = [
          record['Call ID'] || '',
          callTimeKey,
          record.From || '',
          record.To || '',
          record.DirectionClean || '',
          record.StatusClean || '',
          record['Call Activity Details'] || '',
          record.RingingSeconds ?? '',
          record.TalkingSeconds ?? '',
        ].join('|');
        const occurrence = occurrences.get(key) ?? 0;
        occurrences.set(key, occurrence + 1);

        if (occurrence > 0) {
          duplicateCounter += 1;
          return; // on ignore les doublons pour éviter le comptage multiple
        }

        cleanedRows.push(record);
      });
      return { rows: cleanedRows, duplicates: duplicateCounter };
    }

    function directionLabel(value) {
      const key = (value || '').toString().toLowerCase();
      return DIRECTION_LABELS[key] || value;
    }

    function statusLabel(value) {
      const key = (value || '').toString().toLowerCase();
      return STATUS_LABELS[key] || value;
    }

    function populateFilters(data) {
      const directions = Array.from(new Set(
        data.map((d) => (d.DirectionClean || '').toLowerCase()).filter(Boolean),
      ))
        .filter((dir) => dir !== 'inbound queue')
        .sort();
      const statuses = Array.from(new Set(
        data.map((d) => (d.StatusClean || '').toLowerCase()).filter(Boolean),
      )).sort();
      directionSelect.innerHTML = ['<option value="__all__" selected>Toutes les directions</option>']
        .concat(directions.map((dir) => `<option value="${dir}">${directionLabel(dir)}</option>`))
        .join('');
      statusSelect.innerHTML = ['<option value="__all__" selected>Tous les statuts</option>']
        .concat(statuses.map((st) => `<option value="${st}">${statusLabel(st)}</option>`))
        .join('');

      const standardExtensions = Array.from({ length: 31 }, (_, i) => (100 + i).toString());
      const agentOptions = standardExtensions
        .map((ext) => ({ value: ext, label: `${ext} – ${trackedExtensionMap.get(ext) || 'Extension standard'}` }))
        .sort((a, b) => a.value.localeCompare(b.value, 'fr'));

      agentSelect.innerHTML = ['<option value="__all__" selected>Tous les utilisateurs</option>']
        .concat(agentOptions.map((agent) => `<option value="${agent.value}">${agent.label}</option>`))
        .join('');

      const queueOptionsMap = new Map();
      TRACKED_QUEUES.forEach((entry) => {
        const value = entry.number;
        const label = `${entry.number} – ${entry.label}`;
        if (value !== '992') queueOptionsMap.set(value.toLowerCase(), { value, label });
      });

      data
        .filter((d) => (d.QueueLabel || d.QueueNumber) && d.QueueNumber !== '992')
        .forEach((d) => {
          const value = (d.QueueNumber || d.QueueLabel || '').toString();
          const label = [d.QueueNumber, d.QueueLabel].filter(Boolean).join(' – ');
          queueOptionsMap.set(value.toLowerCase(), { value, label: label || value });
        });

      const queueOptions = Array.from(queueOptionsMap.values()).sort((a, b) =>
        a.label.localeCompare(b.label, 'fr'),
      );

      queueSelect.innerHTML = ['<option value="__all__" selected>Toutes les files</option>']
        .concat(queueOptions.map((queue) => `<option value="${queue.value}">${queue.label}</option>`))
        .join('');

      const dates = data.map((d) => d.Date).filter(Boolean).sort();
      if (dates.length) {
        startDateInput.min = endDateInput.min = dates[0];
        startDateInput.max = endDateInput.max = dates[dates.length - 1];
        if (!startDateInput.value) startDateInput.value = dates[0];
        if (!endDateInput.value) endDateInput.value = dates[dates.length - 1];
      }

      if (!startHourInput.value) startHourInput.value = 0;
      if (!endHourInput.value) endHourInput.value = 23;

      saveStatus.textContent = '';
    }

    function applyFilters() {
      if (!rawData.length) return;
      const selectedDirections = extractSelection(directionSelect);
      const selectedStatuses = extractSelection(statusSelect);
      const selectedAgents = extractSelection(agentSelect);
      const selectedQueues = extractSelection(queueSelect);
      const startDate = startDateInput.value ? new Date(startDateInput.value) : null;
      const endDate = endDateInput.value ? new Date(endDateInput.value) : null;
      const startHour = startHourInput.value !== '' ? Number(startHourInput.value) : null;
      const endHour = endHourInput.value !== '' ? Number(endHourInput.value) : null;

      filteredData = rawData.filter((row) => {
        const dir = (row.DirectionClean || '').toLowerCase();
        const status = (row.StatusClean || '').toLowerCase();
        const agentValue = (row.AgentExt || row.AgentLabel || '').toString().toLowerCase();
        const queueValue = (row.QueueNumber || row.QueueLabel || '').toString().toLowerCase();
        const agentMatch = !selectedAgents.length || selectedAgents.includes(agentValue);
        const queueMatch = !selectedQueues.length || selectedQueues.includes(queueValue);

        const dateSource = row.CallTime ?? row.Date ?? null;
        const dateObj = dateSource ? new Date(dateSource) : null;
        const validDate = dateObj instanceof Date && !Number.isNaN(dateObj);
        const dateOk = !validDate || ((!startDate || dateObj >= startDate) && (!endDate || dateObj <= endDate));

        const hasHour = row.Hour !== '' && row.Hour !== null && row.Hour !== undefined;
        const hourOk = !hasHour ||
          (startHour === null && endHour === null) ||
          ((startHour === null || Number(row.Hour) >= startHour) && (endHour === null || Number(row.Hour) <= endHour));

        const dirOk = !selectedDirections.length || selectedDirections.includes(dir);
        const statusOk = !selectedStatuses.length || selectedStatuses.includes(status);
        return agentMatch && queueMatch && dateOk && hourOk && dirOk && statusOk;
      });

      filteredData = filteredData.filter((row) => {
        const queueNumber = (row.QueueNumber || '').toString();
        const agentExtension = (row.AgentExt || '').toString();
        return queueNumber !== '992' && agentExtension !== '992';
      });

      filteredData = filteredData.filter((row) => !isCallScript(row));

      eligibleData = filteredData.filter((row) => row.AgentDirectionMatch || row.QueueTracked);
      standardEligibleData = filterStandardInvolvedCalls(eligibleData);

      callSummaries = summarizeCalls(standardEligibleData);
      callAggregates = callSummaries.filter((call) => call.answered);
      failedCallAggregates = callSummaries.filter((call) => call.queueAbandoned);
      outboundFailureAggregates = callSummaries.filter((call) => call.outboundFailure);
      extensionAggregates = buildExtensionAggregatesFromSummaries(callSummaries);

      selectedDate = null;

      renderKPIs();
      renderSelectionAwareViews();
      renderDataTable();
    }

    function extractSelection(selectEl) {
      const values = Array.from(selectEl.selectedOptions).map((o) => o.value.toLowerCase());
      return values.includes('__all__') ? [] : values;
    }

    function getRowDate(row, callTimeOverride = null) {
      const callTime =
        callTimeOverride ??
        (row.CallTime instanceof Date ? row.CallTime : row.CallTime ? new Date(row.CallTime) : null);

      if (callTime instanceof Date && !Number.isNaN(callTime)) {
        return row.Date || callTime.toISOString().slice(0, 10);
      }

      return row.Date || '';
    }

    function filterStandardInvolvedCalls(rows) {
      const relevantCallIds = new Set();

      rows.forEach((row, index) => {
        const callId = row['Call ID'] || `__missing_${index}`;
        const extValue = Number(row.AgentExt || row.QueueNumber);
        const isStandard = (row.ExtensionCategory || '').toLowerCase() === 'standard';
        const isQueueRange = Number.isFinite(extValue) &&
          extValue >= QUEUE_EXTENSION_RANGE.start &&
          extValue <= QUEUE_EXTENSION_RANGE.end;
        if (isStandard || isQueueRange) {
          relevantCallIds.add(callId);
        }
      });

      return rows.filter((row, index) => {
        const callId = row['Call ID'] || `__missing_${index}`;
        return relevantCallIds.has(callId);
      });
    }

    function summarizeCalls(rows) {
      const byId = new Map();

      rows.forEach((row, index) => {
        const callId = row['Call ID'] || `__missing_${index}`;
        const status = normalizeStatus(row.StatusClean || row.Status);
        const direction = (row.DirectionClean || row.Direction || '').toLowerCase();
        const isInbound = direction.includes('inbound');
        const isOutbound = direction.includes('outbound');
        const extensionCategory = (row.ExtensionCategory || '').toLowerCase();
        const queueValue = Number(row.QueueNumber || row.AgentExt);
        const isQueue = Number.isFinite(queueValue) &&
          queueValue >= QUEUE_EXTENSION_RANGE.start &&
          queueValue <= QUEUE_EXTENSION_RANGE.end;
        const isAnswered = status === 'answered';
        const isStandard = extensionCategory === 'standard';
        const answeredByStandard = isAnswered && isStandard;
        const unansweredFlag =
          status.includes('unanswered') ||
          status.includes('no answer') ||
          status.includes('missed') ||
          status.includes('failed');
        const outboundFailure = isOutbound && unansweredFlag && isStandard;
        const callTime = row.CallTime instanceof Date ? row.CallTime : row.CallTime ? new Date(row.CallTime) : null;
        const talkingSeconds = Number(row.TalkingSeconds) || 0;

        const existing = byId.get(callId) || {
          callId,
          answered: false,
          answeredByStandard: false,
          outboundFailure: false,
          standardPresent: false,
          inbound: false,
          outbound: false,
          isQueue: false,
          queuePresent: false,
          talkingSeconds: 0,
          standardTalkingSeconds: 0,
          queueTalkingSeconds: 0,
          callTime: null,
          date: '',
          hour: '',
          dow: '',
          representativeRow: null,
          queueRow: null,
        };

        existing.inbound = existing.inbound || isInbound;
        existing.outbound = existing.outbound || isOutbound;
        existing.isQueue = existing.isQueue || isQueue;
        existing.queuePresent = existing.queuePresent || isQueue;
        existing.standardPresent = existing.standardPresent || isStandard;
        existing.answeredByStandard = existing.answeredByStandard || answeredByStandard;
        existing.answered = existing.answered || isAnswered;
        existing.outboundFailure = existing.outboundFailure || outboundFailure;
        existing.talkingSeconds = Math.max(existing.talkingSeconds, talkingSeconds);
        if (isStandard) {
          existing.standardTalkingSeconds = Math.max(existing.standardTalkingSeconds, talkingSeconds);
        }
        if (isQueue) {
          existing.queueTalkingSeconds = Math.max(existing.queueTalkingSeconds, talkingSeconds);
        }

        if (callTime && (!existing.callTime || callTime < existing.callTime)) {
          existing.callTime = callTime;
          existing.date = getRowDate(row, callTime);
          existing.hour = callTime.getHours();
          existing.dow = callTime.toLocaleDateString('fr-FR', { weekday: 'long' });
        }

        if (!existing.date) {
          existing.date = getRowDate(row, callTime);
        }

        if (!existing.dow && row.DayOfWeek) {
          existing.dow = row.DayOfWeek;
        }

        if (
          (existing.hour === '' || existing.hour === null || existing.hour === undefined) &&
          row.Hour !== '' &&
          row.Hour !== null &&
          row.Hour !== undefined
        ) {
          existing.hour = Number(row.Hour);
        }

        const hasActor = row.AgentExt || row.QueueTracked;
        const isStandardRow = (row.ExtensionCategory || '').toLowerCase() === 'standard';
        if (!existing.representativeRow && hasActor) {
          existing.representativeRow = row;
        }
        if (isStandardRow) {
          existing.representativeRow = row;
        }

        if (isQueue && (!existing.queueRow || unansweredFlag)) {
          existing.queueRow = row;
        }

        byId.set(callId, existing);
      });

      return Array.from(byId.values()).map((entry) => ({
        ...entry,
        answeredByStandard: entry.answeredByStandard,
        answered: entry.answered,
        outboundFailure: entry.outboundFailure && !entry.answeredByStandard,
        queueAbandoned: entry.queuePresent && !entry.answered,
      }));
    }

    function buildExtensionAggregatesFromSummaries(summaries) {
      const successRows = [];
      const failureRows = [];

      summaries.forEach((call) => {
        if (call.answeredByStandard && call.representativeRow) {
          const standardTalkingSeconds = call.standardTalkingSeconds || call.talkingSeconds;
          successRows.push({ ...call.representativeRow, TalkingSeconds: standardTalkingSeconds });
        }
        if (call.queuePresent && call.queueRow) {
          if (call.answered) {
            const queueTalkingSeconds = call.queueTalkingSeconds || call.talkingSeconds;
            successRows.push({ ...call.queueRow, TalkingSeconds: queueTalkingSeconds });
          } else {
            failureRows.push({ ...call.queueRow, TalkingSeconds: 0 });
          }
        }
        if (call.outboundFailure && call.representativeRow) {
          failureRows.push({ ...call.representativeRow, TalkingSeconds: 0 });
        }
      });

      return aggregateExtensions(successRows, failureRows);
    }

    function aggregateExtensions(successRows, failureRows = []) {
      const perCallCategory = {
        standard: new Map(),
        medecin: new Map(),
        queue: new Map(),
        other: new Map(),
      };

      const resolveBucketInfo = (row, index) => {
        const callId = row['Call ID'] || `__missing_${index}`;
        const isQueue = row.QueueTracked;
        const ext = isQueue ? row.QueueNumber || row.AgentExt || '' : row.AgentExt || '';
        const categoryKey = isQueue
          ? 'queue'
          : perCallCategory[row.ExtensionCategory]
            ? row.ExtensionCategory
            : 'other';

        const labelBase = isQueue
          ? row.QueueLabel || row.QueueNumber || 'File inconnue'
          : row.AgentLabel || row.AgentName || ext || 'Autre / Inconnu';
        const label = labelBase || 'Autre / Inconnu';
        const bucket = perCallCategory[categoryKey] || perCallCategory.other;
        const entryKey = `${callId}|${ext || label}`;

        return { bucket, entryKey, ext, label };
      };

      successRows.forEach((row, index) => {
        const direction = normalizeStatus(row.DirectionClean || row.Direction);
        const isInbound = direction.includes('inbound');
        const isOutbound = direction.includes('outbound');
        const { bucket, entryKey, ext, label } = resolveBucketInfo(row, index);

        const current = bucket.get(entryKey) || {
          label,
          ext: ext || label,
          calls: 0,
          answered: 0,
          failures: 0,
          inbound: 0,
          outbound: 0,
          talking: 0,
        };

        current.calls += 1;
        current.answered += 1;
        current.inbound += isInbound ? 1 : 0;
        current.outbound += isOutbound ? 1 : 0;
        current.talking += Number(row.TalkingSeconds) || 0;
        bucket.set(entryKey, current);
      });

      failureRows.forEach((row, index) => {
        const { bucket, entryKey, ext, label } = resolveBucketInfo(row, index);

        const current = bucket.get(entryKey) || {
          label,
          ext: ext || label,
          calls: 0,
          answered: 0,
          failures: 0,
          inbound: 0,
          outbound: 0,
          talking: 0,
        };

        current.calls += 1;
        current.failures += 1;
        bucket.set(entryKey, current);
      });

      const aggregateBucket = (map) => {
        const grouped = new Map();
        map.forEach((entry) => {
          const key = entry.ext || entry.label;
          const current = grouped.get(key) || {
            label: entry.label,
            ext: entry.ext,
            calls: 0,
            answered: 0,
            failures: 0,
            inbound: 0,
            outbound: 0,
            talking: 0,
          };
          current.calls += entry.calls;
          current.answered += entry.answered;
          current.failures += entry.failures;
          current.inbound += entry.inbound;
          current.outbound += entry.outbound;
          current.talking += entry.talking;
          grouped.set(key, current);
        });
        return Array.from(grouped.values()).sort((a, b) => b.calls - a.calls || b.failures - a.failures);
      };

      return {
        standard: aggregateBucket(perCallCategory.standard),
        medecin: aggregateBucket(perCallCategory.medecin),
        queue: aggregateBucket(perCallCategory.queue),
        other: aggregateBucket(perCallCategory.other),
      };
    }

    function renderKPIs() {
      const answeredCalls = callAggregates.length;
      const queueAbandoned = failedCallAggregates.length;
      const inboundAnsweredCalls = callSummaries.filter((call) => call.inbound && call.answered).length;
      const outboundStandardCalls = callSummaries.filter((call) => call.outbound && call.standardPresent).length;

      const kpis = [
        { label: 'Appels traités', value: answeredCalls },
        { label: "Nombre d'appels entrants répondus", value: inboundAnsweredCalls },
        { label: 'Appels sortants (standard)', value: outboundStandardCalls },
        { label: 'Appels abandonnés', value: queueAbandoned },
      ];

      kpiContainer.innerHTML = kpis
        .map(
          (kpi) => `
            <div class="kpi">
              <div class="label">${kpi.label}</div>
              <div class="value">${kpi.value}</div>
            </div>`,
        )
        .join('');
    }

    function renderCategoryTable(
      container,
      rows,
      {
        answeredLabel = 'Répondus',
        failureLabel = "Échecs d'appel",
        callsLabel = 'Appels',
        showDirectionBreakdown = false,
      } = {},
    ) {
      if (!rows.length) {
        container.innerHTML = '<p class="muted">Aucune donnée à afficher.</p>';
        return;
      }

      const directionHeaders = showDirectionBreakdown
        ? '<th>Appels entrants</th><th>Appels sortants</th>'
        : '';

      const html = `
        <table>
          <thead>
            <tr>
              <th>Extension</th>
              <th>${callsLabel}</th>
              ${directionHeaders}
              <th>${answeredLabel}</th>
              <th>${failureLabel}</th>
              <th>Temps de parole moyen (s)</th>
            </tr>
          </thead>
          <tbody>
            ${rows
              .map(
                (r) => `
                  <tr>
                    <td>${r.label}${r.ext ? ` (${r.ext})` : ''}</td>
                    <td>${r.calls}</td>
                    ${showDirectionBreakdown ? `<td>${r.inbound || 0}</td><td>${r.outbound || 0}</td>` : ''}
                    <td><span class="badge success">${r.answered}</span></td>
                    <td><span class="badge warn">${r.failures}</span></td>
                    <td>${(r.answered ? r.talking / r.answered : 0).toFixed(1)}</td>
                  </tr>`,
              )
              .join('')}
          </tbody>
        </table>`;
      container.innerHTML = html;
    }

    function renderDataTable() {
      const seen = new Set();
      const dataset = filteredData
        .filter((row, index) => {
          const key = `${row['Call ID'] || '__missing'}|${row.CallTime || row.Date || index}`;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        })
        .sort((a, b) => {
          const parseDate = (value) => {
            const date = value ? new Date(value) : null;
            return date instanceof Date && !Number.isNaN(date) ? date.getTime() : -Infinity;
          };
          return parseDate(b.CallTime ?? b.Date) - parseDate(a.CallTime ?? a.Date);
        });

      if (!dataset.length) {
        dataTable.innerHTML = '<p class="muted">Aucune donnée à afficher.</p>';
        return;
      }
      const headers = [
        'Call ID',
        'Call Time',
        'From',
        'To',
        'Direction',
        'Status',
        'AgentLabel',
        'AgentExt',
        'AgentTracked',
        'ExtensionCategory',
        'QueueLabel',
        'QueueNumber',
        'QueueGroup',
        'QueueAssociated',
        'CallType',
        'TalkingSeconds',
        'RingingSeconds',
      ];
      const html = `
        <table>
          <thead>
            <tr>${headers.map((h) => `<th>${h}</th>`).join('')}</tr>
          </thead>
          <tbody>
            ${dataset
              .slice(0, 400)
              .map(
                (row) => `
                  <tr>
                    ${headers
                      .map((h) => `<td>${row[h] ?? row[`${h}Clean`] ?? ''}</td>`)
                      .join('')}
                  </tr>`,
              )
              .join('')}
          </tbody>
        </table>
        <p class="muted">${dataset.length > 400 ? 'Affichage limité aux 400 premières lignes pour garder de bonnes performances.' : ''}</p>`;
      dataTable.innerHTML = html;
    }

    function renderSelectionAwareViews() {
      const { successCalls, failedCalls, scopedExtensions } = buildScopedAggregates();

      renderCategoryTable(standardStats, scopedExtensions.standard || [], {
        answeredLabel: 'Appel traité',
        failureLabel: "Échecs sortants",
        callsLabel: 'Appels',
        showDirectionBreakdown: true,
      });

      renderCategoryTable(queueStats, scopedExtensions.queue || [], {
        answeredLabel: 'Répondus',
        failureLabel: "Abandons (files d'attente)",
        callsLabel: 'Appels',
      });

      renderDateChart();
      renderHourChart(successCalls, failedCalls);
    }

    function buildScopedAggregates() {
      const scopedCalls = selectedDate
        ? callSummaries.filter((call) => call.date === selectedDate)
        : callSummaries;

      return {
        successCalls: scopedCalls.filter((call) => call.answered),
        failedCalls: scopedCalls.filter((call) => call.queueAbandoned),
        scopedExtensions: buildExtensionAggregatesFromSummaries(scopedCalls),
      };
    }

    function renderDateChart(successAggregates = callAggregates, failedAggregates = failedCallAggregates) {
      const successByDate = {};
      const failuresByDate = {};

      successAggregates.forEach((row) => {
        if (row.date) successByDate[row.date] = (successByDate[row.date] || 0) + 1;
      });

      failedAggregates.forEach((row) => {
        if (row.date) failuresByDate[row.date] = (failuresByDate[row.date] || 0) + 1;
      });

      const dateLabels = Array.from(new Set([...Object.keys(successByDate), ...Object.keys(failuresByDate)])).sort(
        (a, b) => new Date(a) - new Date(b),
      );
      const formattedDateLabels = dateLabels.map((d) => formatChartDateLabel(d));
      const successData = dateLabels.map((d) => successByDate[d] || 0);
      const failureData = dateLabels.map((d) => failuresByDate[d] || 0);
      const successColors = dateLabels.map((date) => (date === selectedDate ? '#3b82f6' : '#22c55e'));
      const failureColors = dateLabels.map((date) => (date === selectedDate ? '#fb923c' : '#f97316'));

      createChart('date-chart', 'bar', {
        labels: formattedDateLabels,
        datasets: [
          {
            label: 'Appels',
            data: successData,
            backgroundColor: successColors,
            borderColor: successColors,
            borderWidth: 1.2,
            stack: 'calls',
          },
          {
            label: "Appels abandonnés (files d'attente)",
            data: failureData,
            backgroundColor: failureColors,
            borderColor: failureColors,
            borderWidth: 1.2,
            stack: 'calls',
          },
        ],
      }, {
        onClick: (_, elements) => {
          if (!elements.length) return;
          const clickedIndex = elements[0].index;
          const clickedDate = dateLabels[clickedIndex];
          selectedDate = selectedDate === clickedDate ? null : clickedDate;
          renderSelectionAwareViews();
        },
        scales: { x: { stacked: true }, y: { stacked: true } },
        plugins: { legend: { display: true } },
      });
    }

    function renderHourChart(successAggregates = callAggregates, failedAggregates = failedCallAggregates) {
      const successByHour = Array(24).fill(0);
      const failuresByHour = Array(24).fill(0);

      successAggregates.forEach((row) => {
        if (row.hour !== '' && row.hour !== null && row.hour !== undefined) successByHour[Number(row.hour)] += 1;
      });

      failedAggregates.forEach((row) => {
        if (row.hour !== '' && row.hour !== null && row.hour !== undefined) failuresByHour[Number(row.hour)] += 1;
      });

      createChart('hour-chart', 'bar', {
        labels: Array.from({ length: 24 }, (_, i) => `${i}h`),
        datasets: [
          { label: 'Appels', data: successByHour, backgroundColor: '#22c55e', stack: 'calls' },
          { label: "Appels abandonnés (files d'attente)", data: failuresByHour, backgroundColor: '#f97316', stack: 'calls' },
        ],
      }, { scales: { x: { stacked: true }, y: { stacked: true } }, plugins: { legend: { display: true } } });
    }

    function createChart(id, type, data, options = {}) {
      const ctx = document.getElementById(id);
      if (charts[id]) charts[id].destroy();
      charts[id] = new Chart(ctx, {
        type,
        data,
        options: { responsive: true, plugins: { legend: { display: false } }, ...options },
      });
    }

    function formatChartDateLabel(value) {
      if (!value) return '';
      const date = new Date(value);
      if (!(date instanceof Date) || Number.isNaN(date)) return value;
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}:${month}:${year}`;
    }

    function switchTab(target) {
      tabButtons.forEach((btn) => btn.classList.toggle('active', btn.dataset.tabTarget === target));
      tabSections.forEach((section) => section.classList.toggle('active', section.dataset.tab === target));
      if (target === 'ville92' && carte92Events.length) renderVille92();
    }

    function loadImportLog() {
      const stored = localStorage.getItem('import-log');
      if (!stored) return [];
      try {
        return JSON.parse(stored);
      } catch (e) {
        console.error("Impossible de lire l'historique des imports", e);
        return [];
      }
    }

    function saveImportLog() {
      localStorage.setItem('import-log', JSON.stringify(importLog));
    }

    function formatDate(value) {
      if (!value) return '';
      const date = new Date(value);
      return date instanceof Date && !Number.isNaN(date) ? date.toLocaleString('fr-FR') : '';
    }

    function addImportEntry(importId, fileName, importedAt, rows) {
      if (!rows.length) return;
      const dates = rows
        .map((row) => row.CallTime instanceof Date ? row.CallTime : row.CallTime ? new Date(row.CallTime) : row.Date ? new Date(row.Date) : null)
        .filter((d) => d instanceof Date && !Number.isNaN(d));
      const start = dates.length ? new Date(Math.min(...dates)) : null;
      const end = dates.length ? new Date(Math.max(...dates)) : null;
      importLog.push({
        id: importId,
        fileName,
        importedAt,
        startDate: start ? start.toISOString() : '',
        endDate: end ? end.toISOString() : '',
        rows: rows.length,
      });
      saveImportLog();
      renderImportList();
    }

    function renderImportList() {
      if (!importLog.length) {
        importList.textContent = 'Aucun import enregistré.';
        return;
      }
      const rows = importLog
        .map(
          (entry) => `
            <tr>
              <td>${entry.fileName}</td>
              <td>${formatDate(entry.importedAt)}</td>
              <td>${entry.startDate ? formatDate(entry.startDate) : 'N/A'}</td>
              <td>${entry.endDate ? formatDate(entry.endDate) : 'N/A'}</td>
              <td>${entry.rows}</td>
              <td style="text-align:center"><button data-delete-import="${entry.id}" aria-label="Supprimer l'import" style="width:auto;padding:0.35rem 0.55rem;">✕</button></td>
            </tr>
          `,
        )
        .join('');

      importList.innerHTML = `
        <table>
          <thead>
            <tr>
              <th>Fichier</th>
              <th>Date d'import</th>
              <th>Période minimale</th>
              <th>Période maximale</th>
              <th>Lignes gardées</th>
              <th></th>
            </tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      `;

      importList.querySelectorAll('[data-delete-import]').forEach((btn) => {
        btn.addEventListener('click', () => removeImport(btn.dataset.deleteImport));
      });
    }

    async function removeImport(importId) {
      importLog = importLog.filter((entry) => entry.id !== importId);
      rawData = rawData.filter((row) => row.ImportId !== importId);
      await persistDataset(rawData);
      saveImportLog();
      renderImportList();
      populateFilters(rawData);
      applyFilters();
      fileSummary.textContent = rawData.length
        ? `${rawData.length} lignes restantes après suppression.`
        : 'Aucun fichier chargé.';
    }

    function exportFiltered() {
      const dataset = filteredData;
      if (!dataset.length) return alert('Aucune donnée filtrée à exporter.');
      const headers = Object.keys(dataset[0]);
      const csv = [headers.join(',')].concat(
        dataset.map((row) => headers.map((h) => JSON.stringify(row[h] ?? '')).join(',')),
      );
      const blob = new Blob([csv.join('\n')], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'appels_filtrés.csv';
      a.click();
      URL.revokeObjectURL(url);
    }

    function normalizeCityLabel(value) {
      return (value || '').toString().trim().replace(/\s+/g, ' ');
    }

    function normalizeCityKey(value) {
      return normalizeCityLabel(value).toLowerCase();
    }

    function getTimezoneOffset(date, timeZone = 'Europe/Paris') {
      const dtf = new Intl.DateTimeFormat('en-US', {
        timeZone,
        hour12: false,
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
      });

      const parts = dtf.formatToParts(date).reduce((acc, part) => {
        if (['year', 'month', 'day', 'hour', 'minute', 'second'].includes(part.type)) acc[part.type] = Number(part.value);
        return acc;
      }, {});

      return Date.UTC(parts.year, parts.month - 1, parts.day, parts.hour, parts.minute, parts.second) - date.getTime();
    }

    function buildParisDate(year, month, day, hour = 0, minute = 0) {
      const utcDate = Date.UTC(year, month - 1, day, hour, minute, 0);
      const guess = new Date(utcDate);
      const offset = getTimezoneOffset(guess, 'Europe/Paris');
      return new Date(utcDate - offset);
    }

    function combineFiltersToParisDate(dateValue, timeValue) {
      if (!dateValue) return null;
      const [year, month, day] = dateValue.split('-').map((v) => Number(v));
      const [hour = 0, minute = 0] = (timeValue || '00:00').split(':').map((v) => Number(v));
      if ([year, month, day].some((v) => Number.isNaN(v))) return null;
      return buildParisDate(year, month, day, Number.isFinite(hour) ? hour : 0, Number.isFinite(minute) ? minute : 0);
    }

    function parseCarte92Date(value) {
      const text = (value || '').toString().trim();
      if (!text) return null;
      const match = text.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})\s+(\d{1,2}):(\d{2})$/);
      if (!match) return null;
      const [, d, m, y, hh, mm] = match;
      const year = y.length === 2 ? 2000 + Number(y) : Number(y);
      return buildParisDate(year, Number(m), Number(d), Number(hh), Number(mm));
    }

    function formatDurationLabel(seconds) {
      if (!seconds || Number.isNaN(seconds)) return '0h00';
      const totalMinutes = Math.floor(seconds / 60);
      const hours = Math.floor(totalMinutes / 60);
      const minutes = totalMinutes % 60;
      return `${hours}h${String(minutes).padStart(2, '0')}`;
    }

    function formatInputDate(date) {
      if (!(date instanceof Date) || Number.isNaN(date)) return '';
      const y = date.getFullYear();
      const m = String(date.getMonth() + 1).padStart(2, '0');
      const d = String(date.getDate()).padStart(2, '0');
      return `${y}-${m}-${d}`;
    }

    function handleCarte92Files(files) {
      if (!files?.length) return;
      const imports = Array.from(files).map((file) =>
        parseFile(file)
          .then((rows) => ({ rows, fileName: file.name }))
          .catch((error) => {
            console.error(error);
            return { rows: [], error: true, fileName: file.name };
          }),
      );

      Promise.all(imports).then((items) => {
        let inserted = 0;
        let duplicates = 0;
        let errors = 0;

        items.forEach((item) => {
          if (item.error) return;
          const result = ingestCarte92Rows(item.rows, item.fileName);
          inserted += result.inserted;
          duplicates += result.duplicates;
          errors += result.errors.length;
        });

        const statusParts = [];
        if (inserted) statusParts.push(`${inserted} événement(s) ajouté(s)`);
        if (duplicates) statusParts.push(`${duplicates} doublon(s) ignoré(s)`);
        if (errors) statusParts.push(`${errors} ligne(s) en erreur`);
        ville92ImportStatus.textContent = statusParts.length
          ? `${statusParts.join(' – ')}. Total : ${carte92Events.length} événement(s).`
          : 'Aucun événement ajouté.';

        if (carte92Events.length) {
          initializeVille92Filters();
          renderVille92();
        }
      });
    }

    function ingestCarte92Rows(rows, fileName = '') {
      const normalizedRows = rows.map(normalizeRecord);
      const existingIds = new Set(carte92Events.map((e) => e.eventId));
      const seen = new Set(existingIds);
      const parsed = [];
      const errors = [];
      let duplicates = 0;

      normalizedRows.forEach((row, index) => {
        const createdAt = parseCarte92Date(
          row['créé le'] || row['cree le'] || row['created_at'] || row['date'] || row['created at'] || row['crééle'],
        );
        const cityRaw = row['nom de la ville'] || row.city || row['ville'] || row['nom'] || '';
        const actionRaw = row.action || row['action'] || '';
        const sector = row['secteur 92'] || row['secteur'] || '';
        const operator = row['standardiste'] || row['operateur'] || '';

        if (!createdAt) {
          errors.push(`Ligne ${index + 2} (${fileName}) : date invalide (${row['créé le'] || row['created_at'] || ''}).`);
          return;
        }
        if (!cityRaw) {
          errors.push(`Ligne ${index + 2} (${fileName}) : ville manquante.`);
          return;
        }

        const city = normalizeCityLabel(cityRaw);
        const normalizedCity = normalizeCityKey(cityRaw);
        const actionLower = actionRaw.toString().toLowerCase();
        let action = '';
        if (actionLower.includes('ouverture')) action = 'Ouverture';
        if (actionLower.includes('fermeture')) action = 'Fermeture';
        if (!action) {
          errors.push(`Ligne ${index + 2} (${fileName}) : action inconnue (${actionRaw}).`);
          return;
        }

        const eventId = `${createdAt.toISOString()}|${city}|${action}|${sector}|${operator}`;
        if (seen.has(eventId)) {
          duplicates += 1;
          return;
        }
        seen.add(eventId);
        parsed.push({
          eventId,
          createdAt,
          city,
          normalizedCity,
          action,
          sector,
          operator,
        });
      });

      carte92Events = carte92Events.concat(parsed).sort((a, b) => a.createdAt - b.createdAt);
      return { inserted: parsed.length, duplicates, errors };
    }

    function initializeVille92Filters() {
      if (!carte92Events.length) return;
      const times = carte92Events.map((e) => e.createdAt.getTime());
      const minDate = new Date(Math.min(...times));
      const maxDate = new Date(Math.max(...times));

      ville92Filters = {
        startDate: formatInputDate(minDate),
        endDate: formatInputDate(maxDate),
        startTime: '00:00',
        endTime: '23:59',
      };

      ville92StartDateInput.value = ville92Filters.startDate;
      ville92EndDateInput.value = ville92Filters.endDate;
      ville92StartTimeInput.value = ville92Filters.startTime;
      ville92EndTimeInput.value = ville92Filters.endTime;
    }

    function resetVille92Filters() {
      initializeVille92Filters();
      ville92Error.textContent = '';
      renderVille92();
    }

    function applyVille92Filters() {
      if (!carte92Events.length) {
        ville92Error.textContent = 'Importez des événements carte 92 pour lancer le calcul.';
        return;
      }

      const startDate = ville92StartDateInput.value;
      const endDate = ville92EndDateInput.value;
      const startTime = ville92StartTimeInput.value || '00:00';
      const endTime = ville92EndTimeInput.value || '23:59';

      const start = combineFiltersToParisDate(startDate, startTime);
      const end = combineFiltersToParisDate(endDate, endTime);

      if (!start || !end) {
        ville92Error.textContent = 'Dates/horaires invalides : les champs de dates sont obligatoires.';
        return;
      }

      if (end < start) {
        ville92Error.textContent = 'La fin doit être postérieure ou égale au début.';
        return;
      }

      ville92Filters = { startDate, endDate, startTime, endTime };
      ville92Error.textContent = '';
      renderVille92();
    }

    async function loadCarte92Geojson() {
      if (carte92Geojson) return carte92Geojson;
      try {
        const response = await fetch('assets/communes-hauts-de-seine.geojson');
        carte92Geojson = await response.json();
      } catch (error) {
        console.error('Impossible de charger le GeoJSON des communes 92', error);
      }
      return carte92Geojson || { type: 'FeatureCollection', features: [] };
    }

    function ensureVille92Map() {
      if (ville92Map) return;
      ville92Map = L.map('ville92-map').setView([48.84, 2.25], 10.5);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap',
      }).addTo(ville92Map);
    }

    function interpolateColor(start, end, t) {
      const clamped = Math.min(1, Math.max(0, t));
      const toHex = (value) => value.toString(16).padStart(2, '0');
      const r = Math.round(start[0] + (end[0] - start[0]) * clamped);
      const g = Math.round(start[1] + (end[1] - start[1]) * clamped);
      const b = Math.round(start[2] + (end[2] - start[2]) * clamped);
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    function buildCarte92Metrics(events, start, end) {
      const metrics = {};
      const totalInterval = Math.max((end - start) / 1000, 0);
      const grouped = events.reduce((acc, event) => {
        const key = event.normalizedCity;
        acc[key] = acc[key] || [];
        acc[key].push(event);
        return acc;
      }, {});

      Object.entries(grouped).forEach(([cityKey, cityEvents]) => {
        const ordered = cityEvents.slice().sort((a, b) => a.createdAt - b.createdAt);
        const windowEvents = ordered.filter((e) => e.createdAt >= start && e.createdAt <= end);
        const priorEvents = ordered.filter((e) => e.createdAt < start);
        const lastPrior = priorEvents.length ? priorEvents[priorEvents.length - 1] : null;
        let isOpen = lastPrior ? lastPrior.action === 'Ouverture' : false;
        let cursor = start;
        let openSeconds = 0;

        windowEvents.forEach((event) => {
          if (isOpen) openSeconds += (event.createdAt - cursor) / 1000;
          isOpen = event.action === 'Ouverture';
          cursor = event.createdAt;
        });

        if (isOpen) openSeconds += (end - cursor) / 1000;

        metrics[cityKey] = {
          percentOpen: totalInterval > 0 ? openSeconds / totalInterval : 0,
          durationOpen: openSeconds,
          totalInterval,
          eventCount: windowEvents.length,
          hasPrior: Boolean(lastPrior),
          totalEvents: ordered.length,
          initialState: lastPrior ? (lastPrior.action === 'Ouverture' ? 'open' : 'closed') : 'closed',
          cityLabel: cityEvents[0]?.city || cityKey,
        };
      });

      return metrics;
    }

    function injectMetricsIntoGeojson(geojson, metrics, totalInterval) {
      const cityLabels = Object.entries(metrics).reduce((acc, [key, value]) => {
        acc[key] = value.cityLabel || key;
        return acc;
      }, {});
      const unmatchedCities = new Set(Object.keys(metrics));
      const features = (geojson?.features || []).map((feature) => {
        const props = feature.properties || {};
        const cityName = props.nom || props.name || '';
        const normalized = normalizeCityKey(cityName);
        const metric = metrics[normalized] || {
          percentOpen: 0,
          durationOpen: 0,
          totalInterval,
          eventCount: 0,
          hasPrior: false,
          totalEvents: 0,
          initialState: 'closed',
        };

        if (metrics[normalized]) unmatchedCities.delete(normalized);

        const percent = Math.max(0, Math.min(1, metric.percentOpen ?? 0));
        const fillColor = interpolateColor([239, 68, 68], [34, 197, 94], percent);
        const tooltipLines = [`Ouverture : ${Math.round(percent * 100)}%`];

        if (!metric.totalEvents) {
          tooltipLines.push('Aucun événement');
        } else {
          tooltipLines.push(`Ouvert ${formatDurationLabel(metric.durationOpen)} / ${formatDurationLabel(metric.totalInterval)}`);
          tooltipLines.push(`${metric.eventCount} événement(s)`);
          if (!metric.hasPrior) tooltipLines.push('État initial supposé fermé');
        }

        return {
          ...feature,
          properties: {
            ...props,
            percentOpen: metric.percentOpen,
            fillColor,
            tooltip: [cityName || 'Commune inconnue', ...tooltipLines].join('<br/>'),
            eventCount: metric.eventCount,
          },
        };
      });

      return { features, unmatchedCities: Array.from(unmatchedCities).map((key) => cityLabels[key] || key) };
    }

    function renderVille92Legend() {
      if (!ville92Legend) return;
      ville92Legend.innerHTML = `
        <span><span class="swatch" style="background:#ef4444"></span>0% ouvert</span>
        <span><span class="swatch" style="background:${interpolateColor([239,68,68],[34,197,94],0.5)}"></span>50%</span>
        <span><span class="swatch" style="background:#22c55e"></span>100% ouvert</span>
      `;
    }

    function renderVille92SummaryTable(features) {
      if (!ville92Summary) return;
      if (!features.length) {
        ville92Summary.innerHTML = '<p class="muted">Aucune donnée cartographique disponible.</p>';
        return;
      }

      const rows = features
        .map((feature) => feature.properties || {})
        .map((props) => ({
          name: props.nom || props.name || 'Commune',
          percent: Math.round((props.percentOpen ?? 0) * 100),
          events: props.eventCount ?? 0,
          comment: !props.eventCount ? 'Aucun événement' : props.percentOpen === 0 ? 'Fermé sur la période' : '',
        }))
        .sort((a, b) => a.name.localeCompare(b.name, 'fr'));

      const html = `
        <table class="ville92-table">
          <thead>
            <tr>
              <th>Ville</th>
              <th>% ouverture</th>
              <th>Événements utilisés</th>
              <th>Commentaire</th>
            </tr>
          </thead>
          <tbody>
            ${rows
              .map(
                (row) => `
                  <tr>
                    <td>${row.name}</td>
                    <td>${row.percent}%</td>
                    <td>${row.events}</td>
                    <td>${row.comment}</td>
                  </tr>`,
              )
              .join('')}
          </tbody>
        </table>`;

      ville92Summary.innerHTML = html;
    }

    async function renderVille92() {
      if (!carte92Events.length) {
        ville92Summary.innerHTML = '<p class="muted">Importez des événements pour afficher la carte.</p>';
        return;
      }

      const start = combineFiltersToParisDate(ville92Filters.startDate, ville92Filters.startTime);
      const end = combineFiltersToParisDate(ville92Filters.endDate, ville92Filters.endTime);
      if (!start || !end || end < start) {
        ville92Error.textContent = 'La période choisie est invalide.';
        return;
      }

      ensureVille92Map();
      const totalInterval = Math.max((end - start) / 1000, 0);
      const metrics = buildCarte92Metrics(carte92Events, start, end);
      ville92LastMetrics = metrics;

      const geojson = await loadCarte92Geojson();
      const { features, unmatchedCities } = injectMetricsIntoGeojson(geojson, metrics, totalInterval);

      if (ville92Layer) ville92Map.removeLayer(ville92Layer);
      ville92Layer = L.geoJSON({ type: 'FeatureCollection', features }, {
        style: (feature) => ({
          color: '#475569',
          weight: 1,
          fillColor: feature.properties.fillColor || '#9ca3af',
          fillOpacity: 0.7,
        }),
        onEachFeature: (feature, layer) => {
          const tooltip = feature.properties.tooltip || '';
          layer.bindTooltip(tooltip, { sticky: true });
        },
      }).addTo(ville92Map);

      if (features.length) {
        const bounds = ville92Layer.getBounds();
        if (bounds.isValid()) ville92Map.fitBounds(bounds, { padding: [12, 12] });
      }
      renderVille92Legend();
      renderVille92SummaryTable(features);
      ville92Unmatched.textContent = unmatchedCities.length
        ? `Villes non matchées avec le GeoJSON : ${unmatchedCities.join(', ')}`
        : '';
    }

    importLog = loadImportLog();
    renderImportList();
    switchTab('pilotage');
    restoreFromIndexedDB();
  </script>
</body>
</html>
